LLVMFuzzerInitialize:
  252|      2|            pub extern "C" fn LLVMFuzzerInitialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
  253|      2|                $crate::initialize(_argc, _argv);
  254|       |
  255|       |                // Supplied init code
  256|       |                $init;
  257|      2|                0
  258|      2|            }
_RNvNvCs8IHyuhOPnlA_12fuzz_compile1__19___libfuzzer_sys_run:
  293|  1.31k|            fn __libfuzzer_sys_run($bytes: &[u8]) -> $rty {
  294|       |                $body
  295|  1.31k|            }
rust_fuzzer_test_input:
  261|  1.31k|            pub extern "C" fn rust_fuzzer_test_input(bytes: &[u8]) -> i32 {
  262|       |                // When `RUST_LIBFUZZER_DEBUG_PATH` is set, write the debug
  263|       |                // formatting of the input to that file. This is only intended for
  264|       |                // `cargo fuzz`'s use!
  265|       |
  266|       |                // `RUST_LIBFUZZER_DEBUG_PATH` is set in initialization.
  267|  1.31k|                if let Some(path) = $crate::rust_libfuzzer_debug_path() {
  268|       |                    use std::io::Write;
  269|      0|                    let mut file = std::fs::File::create(path)
  270|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  271|      0|                    writeln!(&mut file, "{:?}", bytes)
  272|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  273|      0|                    return 0;
  274|  1.31k|                }
  275|       |
  276|  1.31k|                let result = ::libfuzzer_sys::Corpus::from(__libfuzzer_sys_run(bytes));
  277|  1.31k|                result.to_libfuzzer_code()
  278|  1.31k|            }
LLVMFuzzerTestOneInput:
   59|  1.31k|pub unsafe fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   60|  1.31k|    let test_input = ::std::panic::catch_unwind(|| {
   61|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   62|       |        rust_fuzzer_test_input(data_slice)
   63|       |    });
   64|       |
   65|  1.31k|    match test_input {
   66|  1.31k|        Ok(i) => i,
   67|       |        Err(_) => {
   68|       |            // hopefully the custom panic hook will be called before and abort the
   69|       |            // process before the stack frames are unwinded.
   70|      0|            ::std::process::abort();
   71|       |        }
   72|       |    }
   73|  1.31k|}
_RNCNvCs5DACv3fyMjG_13libfuzzer_sys15test_input_wrap0B3_:
   60|  1.31k|    let test_input = ::std::panic::catch_unwind(|| {
   61|  1.31k|        let data_slice = ::std::slice::from_raw_parts(data, size);
   62|  1.31k|        rust_fuzzer_test_input(data_slice)
   63|  1.31k|    });
_RNCNvCs5DACv3fyMjG_13libfuzzer_sys25rust_libfuzzer_debug_path0B3_:
   78|      1|    RUST_LIBFUZZER_DEBUG_PATH.get_or_init(|| std::env::var("RUST_LIBFUZZER_DEBUG_PATH").ok())
_RNvCs5DACv3fyMjG_13libfuzzer_sys10initialize:
   82|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   83|       |    // Registers a panic hook that aborts the process before unwinding.
   84|       |    // It is useful to abort before unwinding so that the fuzzer will then be
   85|       |    // able to analyse the process stack frames to tell different bugs appart.
   86|       |    //
   87|       |    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   88|       |    // impossible to build code using compiler plugins with this flag.
   89|       |    // We will be able to remove this code when
   90|       |    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   91|      2|    let default_hook = std::panic::take_hook();
   92|      2|    std::panic::set_hook(Box::new(move |panic_info| {
   93|       |        default_hook(panic_info);
   94|       |        std::process::abort();
   95|       |    }));
   96|      2|    0
   97|      2|}
_RNvCs5DACv3fyMjG_13libfuzzer_sys25rust_libfuzzer_debug_path:
   76|  1.31k|pub fn rust_libfuzzer_debug_path() -> &'static Option<String> {
   77|       |    static RUST_LIBFUZZER_DEBUG_PATH: OnceLock<Option<String>> = OnceLock::new();
   78|  1.31k|    RUST_LIBFUZZER_DEBUG_PATH.get_or_init(|| std::env::var("RUST_LIBFUZZER_DEBUG_PATH").ok())
   79|  1.31k|}
_RNvMs_Cs5DACv3fyMjG_13libfuzzer_sysNtB4_6Corpus17to_libfuzzer_code:
   40|  1.31k|    pub fn to_libfuzzer_code(self) -> i32 {
   41|  1.31k|        match self {
   42|  1.31k|            Corpus::Keep => 0,
   43|      0|            Corpus::Reject => -1,
   44|       |        }
   45|  1.31k|    }

_RNvNvCs8IHyuhOPnlA_12fuzz_compile7CODEGEN6___initB3_:
   83|      1|        fn __init() -> $t {
   84|       |            $init
   85|      1|        }
_RNCNkNvCs8IHyuhOPnlA_12fuzz_compile7CODEGEN00B5_:
   90|  1.31k|                    |init| {
   91|       |                        #[thread_local]
   92|       |                        static VAL: $crate::thread::local_impl::LazyStorage<$t, ()>
   93|       |                            = $crate::thread::local_impl::LazyStorage::new();
   94|  1.31k|                        VAL.get_or_init(init, __init)
   95|  1.31k|                    }

_RNvMNtCsgRQV1LU64Ti_10rustcc_ast15binary_operatorNtB2_14BinaryOperator10precedence:
   26|  21.3k|    pub const fn precedence(&self) -> u8 {
   27|       |        use BinaryOperator::{
   28|       |            Add, Assignment, BitwiseAnd, BitwiseLeftShift, BitwiseOr, BitwiseRightShift,
   29|       |            BitwiseXor, Divide, Equals, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual,
   30|       |            LogicalAnd, LogicalOr, Multiply, NotEquals, Remainder, Subtract,
   31|       |        };
   32|       |
   33|       |        // Reference: https://en.cppreference.com/w/c/language/operator_precedence.html
   34|  21.3k|        match self {
   35|  3.56k|            Multiply | Divide | Remainder => 110,
   36|  2.69k|            Add | Subtract => 100,
   37|  1.74k|            BitwiseLeftShift | BitwiseRightShift => 90,
   38|  4.73k|            LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual => 80,
   39|  2.07k|            Equals | NotEquals => 70,
   40|    987|            BitwiseAnd => 60,
   41|    969|            BitwiseXor => 50,
   42|  1.50k|            BitwiseOr => 40,
   43|    869|            LogicalAnd => 30,
   44|    899|            LogicalOr => 20,
   45|  1.32k|            Assignment => 10,
   46|       |        }
   47|  21.3k|    }

_RNvMNtCsgRQV1LU64Ti_10rustcc_ast9statementNtB2_9Statement10new_return:
   23|  1.57k|    pub const fn new_return(expression: Expression<'a>, range: SourceRange<'a>) -> Self {
   24|  1.57k|        Self::new(StatementKind::Return(expression), range)
   25|  1.57k|    }
_RNvMNtCsgRQV1LU64Ti_10rustcc_ast9statementNtB2_9Statement3new:
   18|  1.57k|    pub const fn new(kind: StatementKind<'a>, range: SourceRange<'a>) -> Self {
   19|  1.57k|        Self { kind, range }
   20|  1.57k|    }

_RNvMNtCsgRQV1LU64Ti_10rustcc_ast16translation_unitNtB2_15TranslationUnit3new:
   12|  1.31k|    pub const fn new() -> Self {
   13|  1.31k|        Self {
   14|  1.31k|            function: Vec::new(),
   15|  1.31k|        }
   16|  1.31k|    }

_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen10complement:
  122|    317|    fn complement(&self, value: LLVMValue) -> LLVMValue {
  123|    317|        self.builder.bitwise_complement(value)
  124|    317|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen10int32_type:
   82|  17.4k|    fn int32_type(&self) -> LLVMType {
   83|  17.4k|        self.context.int32_type()
   84|  17.4k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen11logical_not:
  127|  3.44k|    fn logical_not(&self, value: LLVMValue) -> LLVMValue {
  128|       |        // 1. Check if the value == 0
  129|  3.44k|        let zero = self.const_int(0);
  130|  3.44k|        let value = self.builder.integer_equal(value, zero);
  131|       |
  132|       |        // 2. Zero-extend the i1 result to i32
  133|  3.44k|        self.builder.zero_extend(value, self.int32_type())
  134|  3.44k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen12reset_module:
   68|  1.31k|    pub fn reset_module(&mut self, file_path: &str) -> Result<(), CodegenError> {
   69|       |        // Create a fresh module within the existing context.
   70|  1.31k|        let new_module = LLVMModule::new_in_context(file_path, &self.context)
   71|  1.31k|            .ok_or(CodegenError::FailedModuleCreation)?;
   72|       |        // Replace the module; old module will be disposed via Drop.
   73|  1.31k|        self.module = new_module;
   74|  1.31k|        Ok(())
   75|  1.31k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen16codegen_function:
  143|  1.57k|    fn codegen_function(&self, function: &FunctionDefinition) -> bool {
  144|       |        // Create the function type
  145|  1.57k|        let function_type = function_type(self.int32_type());
  146|       |
  147|       |        // Create the function
  148|  1.57k|        let llvm_function = self.function(&function.name, function_type);
  149|       |
  150|       |        // Create a basic block in the function and set our builder to generate
  151|       |        // code in it.
  152|  1.57k|        self.function_basic_block("entry", llvm_function);
  153|       |
  154|       |        // Codegen the function body
  155|  1.57k|        self.codegen_statement(&function.body);
  156|       |
  157|       |        // Verify generated function and when fuzzing abort on failure
  158|       |        #[cfg(not(fuzzing))]
  159|       |        if !verify_function(
  160|       |            llvm_function,
  161|       |            LLVMVerifierFailureAction::LLVMPrintMessageAction,
  162|       |        ) {
  163|       |            println!("Function verification failed");
  164|       |            return false;
  165|       |        }
  166|       |        #[cfg(fuzzing)]
  167|  1.57k|        let _ = verify_function(
  168|  1.57k|            llvm_function,
  169|  1.57k|            LLVMVerifierFailureAction::LLVMAbortProcessAction,
  170|  1.57k|        );
  171|       |
  172|  1.57k|        true
  173|  1.57k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen17codegen_statement:
  175|  1.57k|    fn codegen_statement(&self, statement: &Statement) {
  176|  1.57k|        match &statement.kind {
  177|  1.57k|            StatementKind::Return(expression) => {
  178|  1.57k|                let value = self.codegen_expression(expression);
  179|  1.57k|
  180|  1.57k|                self.builder.ret(value);
  181|  1.57k|            }
  182|       |        }
  183|  1.57k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen18codegen_binary_add:
  259|    198|    fn codegen_binary_add(&self, left: &Expression, right: &Expression) -> LLVMValue {
  260|    198|        let left_value = self.codegen_expression(left);
  261|    198|        let right_value = self.codegen_expression(right);
  262|       |
  263|    198|        self.builder.add(left_value, right_value)
  264|    198|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen18codegen_expression:
  185|  15.2k|    fn codegen_expression(&self, expression: &Expression) -> LLVMValue {
  186|       |        use ExpressionKind::{BinaryOperation, IntegerLiteral, Parenthesis, UnaryOperation};
  187|       |
  188|  15.2k|        match &expression.kind {
  189|  5.54k|            IntegerLiteral(value) => self.const_int(*value),
  190|       |            UnaryOperation {
  191|  4.32k|                operator,
  192|  4.32k|                expression,
  193|  4.32k|            } => self.codegen_unary_operation(operator, expression.as_ref()),
  194|  1.24k|            Parenthesis(expression) => self.codegen_expression(expression),
  195|       |            BinaryOperation {
  196|  4.16k|                operator,
  197|  4.16k|                left,
  198|  4.16k|                right,
  199|  4.16k|            } => self.codegen_binary_operation(operator, left, right),
  200|       |        }
  201|  15.2k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen20function_basic_block:
   95|  1.57k|    fn function_basic_block(&self, name: &str, function: LLVMFunctionValue) -> LLVMBasicBlock {
   96|  1.57k|        let basic_block = self
   97|  1.57k|            .context
   98|  1.57k|            .create_basic_block_for_function(&function, name);
   99|       |
  100|       |        // Move the builder to the end of the basic block
  101|  1.57k|        self.builder.position_at_end(basic_block);
  102|       |
  103|  1.57k|        basic_block
  104|  1.57k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen20get_current_function:
  108|    477|    fn get_current_function(&self) -> LLVMFunctionValue {
  109|    477|        self.builder
  110|    477|            .get_insert_block()
  111|    477|            .expect("No insert block")
  112|    477|            .get_parent()
  113|    477|            .expect("No parent function")
  114|    477|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen21codegen_binary_divide:
  280|    195|    fn codegen_binary_divide(&self, left: &Expression, right: &Expression) -> LLVMValue {
  281|    195|        let left_value = self.codegen_expression(left);
  282|    195|        let right_value = self.codegen_expression(right);
  283|       |
  284|    195|        self.builder.signed_divide(left_value, right_value)
  285|    195|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen21codegen_binary_equals:
  471|    194|    fn codegen_binary_equals(&self, left: &Expression, right: &Expression) -> LLVMValue {
  472|    194|        let left_value = self.codegen_expression(left);
  473|    194|        let right_value = self.codegen_expression(right);
  474|       |
  475|    194|        let value = self.builder.integer_equal(left_value, right_value);
  476|    194|        self.builder.zero_extend(value, self.int32_type())
  477|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen23codegen_binary_multiply:
  273|    196|    fn codegen_binary_multiply(&self, left: &Expression, right: &Expression) -> LLVMValue {
  274|    196|        let left_value = self.codegen_expression(left);
  275|    196|        let right_value = self.codegen_expression(right);
  276|       |
  277|    196|        self.builder.multiply(left_value, right_value)
  278|    196|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen23codegen_binary_subtract:
  266|    197|    fn codegen_binary_subtract(&self, left: &Expression, right: &Expression) -> LLVMValue {
  267|    197|        let left_value = self.codegen_expression(left);
  268|    197|        let right_value = self.codegen_expression(right);
  269|       |
  270|    197|        self.builder.subtract(left_value, right_value)
  271|    197|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen23codegen_unary_operation:
  242|  4.32k|    fn codegen_unary_operation(
  243|  4.32k|        &self,
  244|  4.32k|        operator: &UnaryOperator,
  245|  4.32k|        expression: &Expression,
  246|  4.32k|    ) -> LLVMValue {
  247|       |        use UnaryOperator::{Complement, LogicalNot, Negate, Positive};
  248|       |
  249|  4.32k|        let value = self.codegen_expression(expression);
  250|       |
  251|  4.32k|        match operator {
  252|    295|            Positive => value,
  253|    261|            Negate => self.negate(value),
  254|    317|            Complement => self.complement(value),
  255|  3.44k|            LogicalNot => self.logical_not(value),
  256|       |        }
  257|  4.32k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen24codegen_binary_less_than:
  487|    203|    fn codegen_binary_less_than(&self, left: &Expression, right: &Expression) -> LLVMValue {
  488|    203|        let left_value = self.codegen_expression(left);
  489|    203|        let right_value = self.codegen_expression(right);
  490|       |
  491|    203|        let value = self
  492|    203|            .builder
  493|    203|            .integer_signed_less_than(left_value, right_value);
  494|    203|        self.builder.zero_extend(value, self.int32_type())
  495|    203|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen24codegen_binary_operation:
  203|  4.16k|    fn codegen_binary_operation(
  204|  4.16k|        &self,
  205|  4.16k|        operator: &BinaryOperator,
  206|  4.16k|        left: &Expression,
  207|  4.16k|        right: &Expression,
  208|  4.16k|    ) -> LLVMValue {
  209|       |        use BinaryOperator::{
  210|       |            Add, Assignment, BitwiseAnd, BitwiseLeftShift, BitwiseOr, BitwiseRightShift,
  211|       |            BitwiseXor, Divide, Equals, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual,
  212|       |            LogicalAnd, LogicalOr, Multiply, NotEquals, Remainder, Subtract,
  213|       |        };
  214|       |
  215|  4.16k|        match operator {
  216|    198|            Add => self.codegen_binary_add(left, right),
  217|    197|            Subtract => self.codegen_binary_subtract(left, right),
  218|    196|            Multiply => self.codegen_binary_multiply(left, right),
  219|    195|            Divide => self.codegen_binary_divide(left, right),
  220|    214|            Remainder => self.codegen_binary_remainder(left, right),
  221|    203|            BitwiseAnd => self.codegen_binary_bitwise_and(left, right),
  222|    194|            BitwiseLeftShift => self.codegen_binary_bitwise_left_shift(left, right),
  223|    195|            BitwiseOr => self.codegen_binary_bitwise_or(left, right),
  224|    200|            BitwiseRightShift => self.codegen_binary_bitwise_right_shift(left, right),
  225|    194|            BitwiseXor => self.codegen_binary_bitwise_xor(left, right),
  226|    283|            LogicalAnd => self.codegen_binary_logical_and(left, right),
  227|    194|            LogicalOr => self.codegen_binary_logical_or(left, right),
  228|       |            Assignment => {
  229|       |                // TODO: For now, we don't support variables, so just evaluate the right-hand
  230|       |                // side
  231|    194|                self.codegen_expression(right)
  232|       |            }
  233|    194|            Equals => self.codegen_binary_equals(left, right),
  234|    194|            NotEquals => self.codegen_binary_not_equals(left, right),
  235|    203|            LessThan => self.codegen_binary_less_than(left, right),
  236|    194|            LessThanOrEqual => self.codegen_binary_less_than_or_equal(left, right),
  237|    505|            GreaterThan => self.codegen_binary_greater_than(left, right),
  238|    218|            GreaterThanOrEqual => self.codegen_binary_greater_than_or_equal(left, right),
  239|       |        }
  240|  4.16k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen24codegen_binary_remainder:
  287|    214|    fn codegen_binary_remainder(&self, left: &Expression, right: &Expression) -> LLVMValue {
  288|    214|        let left_value = self.codegen_expression(left);
  289|    214|        let right_value = self.codegen_expression(right);
  290|       |
  291|    214|        self.builder.signed_remainder(left_value, right_value)
  292|    214|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen25codegen_binary_bitwise_or:
  312|    195|    fn codegen_binary_bitwise_or(&self, left: &Expression, right: &Expression) -> LLVMValue {
  313|    195|        let left_value = self.codegen_expression(left);
  314|    195|        let right_value = self.codegen_expression(right);
  315|       |
  316|    195|        self.builder.bitwise_or(left_value, right_value)
  317|    195|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen25codegen_binary_logical_or:
  405|    194|    fn codegen_binary_logical_or(&self, left: &Expression, right: &Expression) -> LLVMValue {
  406|       |        // NOTE: Logical OR is a short-circuiting operator.
  407|       |        // This means that if the left operand is true, the right operand is not
  408|       |        // evaluated.
  409|    194|        let left_value = self.codegen_expression(left);
  410|       |
  411|       |        // Check if left_value is not zero (true)
  412|    194|        let zero = self.const_int(0);
  413|    194|        let left_is_true = self.builder.integer_not_equal(left_value, zero);
  414|       |
  415|       |        // Get the current function to create a new basic blocks
  416|    194|        let function = self.get_current_function();
  417|       |
  418|       |        // Create basic blocks for the right-hand side and the true case
  419|    194|        let rhs_basic_block = self.context.create_basic_block("lor.rhs");
  420|    194|        let true_basic_block = self.context.create_basic_block("lor.true");
  421|    194|        let false_basic_block = self.context.create_basic_block("lor.false");
  422|    194|        let end_basic_block = self.context.create_basic_block("lor.end");
  423|       |
  424|       |        // Conditionally branch to the true case or the right-hand side if left is false
  425|    194|        self.builder
  426|    194|            .conditional_branch(left_is_true, true_basic_block, rhs_basic_block);
  427|       |
  428|       |        // Build the rhs basic block
  429|    194|        self.builder.position_at_end(rhs_basic_block);
  430|    194|        function.append_existing_basic_block(rhs_basic_block);
  431|       |
  432|    194|        let right_value = self.codegen_expression(right);
  433|       |
  434|       |        // Check if right_value is not zero
  435|    194|        let right_is_true = self.builder.integer_not_equal(right_value, zero);
  436|       |
  437|       |        // Branch to the true or false basic block based on right_is_true
  438|    194|        self.builder
  439|    194|            .conditional_branch(right_is_true, true_basic_block, false_basic_block);
  440|       |
  441|       |        // Build the true basic block
  442|    194|        self.builder.position_at_end(true_basic_block);
  443|    194|        self.builder.unconditional_branch(end_basic_block);
  444|       |
  445|       |        // Build the false basic block
  446|    194|        self.builder.position_at_end(false_basic_block);
  447|    194|        self.builder.unconditional_branch(end_basic_block);
  448|       |
  449|       |        // Build the end merger basic block
  450|    194|        self.builder.position_at_end(end_basic_block);
  451|       |
  452|       |        // Create a PHI node to merge the results
  453|    194|        let phi = self.builder.phi(self.int32_type(), "lor.phi");
  454|    194|        let true_value = self.const_int(1);
  455|    194|        let false_value = self.const_int(0);
  456|       |
  457|       |        // Add incoming values to the PHI node
  458|    194|        phi.add_incoming(
  459|    194|            &[true_value, false_value],
  460|    194|            &[true_basic_block, false_basic_block],
  461|       |        );
  462|       |
  463|       |        // Append all our new basic blocks to the function
  464|    194|        function.append_existing_basic_block(true_basic_block);
  465|    194|        function.append_existing_basic_block(false_basic_block);
  466|    194|        function.append_existing_basic_block(end_basic_block);
  467|       |
  468|    194|        phi.value()
  469|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen25codegen_binary_not_equals:
  479|    194|    fn codegen_binary_not_equals(&self, left: &Expression, right: &Expression) -> LLVMValue {
  480|    194|        let left_value = self.codegen_expression(left);
  481|    194|        let right_value = self.codegen_expression(right);
  482|       |
  483|    194|        let value = self.builder.integer_not_equal(left_value, right_value);
  484|    194|        self.builder.zero_extend(value, self.int32_type())
  485|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen26codegen_binary_bitwise_and:
  294|    203|    fn codegen_binary_bitwise_and(&self, left: &Expression, right: &Expression) -> LLVMValue {
  295|    203|        let left_value = self.codegen_expression(left);
  296|    203|        let right_value = self.codegen_expression(right);
  297|       |
  298|    203|        self.builder.bitwise_and(left_value, right_value)
  299|    203|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen26codegen_binary_bitwise_xor:
  331|    194|    fn codegen_binary_bitwise_xor(&self, left: &Expression, right: &Expression) -> LLVMValue {
  332|    194|        let left_value = self.codegen_expression(left);
  333|    194|        let right_value = self.codegen_expression(right);
  334|       |
  335|    194|        self.builder.bitwise_xor(left_value, right_value)
  336|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen26codegen_binary_logical_and:
  338|    283|    fn codegen_binary_logical_and(&self, left: &Expression, right: &Expression) -> LLVMValue {
  339|       |        // NOTE: Logical AND is a short-circuiting operator.
  340|       |        // This means that if the left operand is false, the right operand is not
  341|       |        // evaluated.
  342|    283|        let left_value = self.codegen_expression(left);
  343|       |
  344|       |        // Check if left_value is zero
  345|    283|        let zero = self.const_int(0);
  346|    283|        let left_is_true = self.builder.integer_not_equal(left_value, zero);
  347|       |
  348|       |        // Get the current function to create a new basic blocks
  349|    283|        let function = self.get_current_function();
  350|       |
  351|       |        // Create basic blocks for the right-hand side and the false case
  352|    283|        let rhs_basic_block = self.context.create_basic_block("land.rhs");
  353|    283|        let false_basic_block = self.context.create_basic_block("land.false");
  354|    283|        let true_basic_block = self.context.create_basic_block("land.true");
  355|    283|        let end_basic_block = self.context.create_basic_block("land.end");
  356|       |
  357|       |        // Conditionally branch to the right-hand side or the false case if left is
  358|       |        // false
  359|    283|        self.builder
  360|    283|            .conditional_branch(left_is_true, rhs_basic_block, false_basic_block);
  361|       |
  362|       |        // Build the rhs basic block
  363|    283|        function.append_existing_basic_block(rhs_basic_block);
  364|    283|        self.builder.position_at_end(rhs_basic_block);
  365|       |
  366|    283|        let right_value = self.codegen_expression(right);
  367|       |
  368|       |        // Check if right_value is not zero
  369|    283|        let right_is_true = self.builder.integer_not_equal(right_value, zero);
  370|       |
  371|       |        // Branch to the true or false basic block based on right_is_false
  372|    283|        self.builder
  373|    283|            .conditional_branch(right_is_true, true_basic_block, false_basic_block);
  374|       |
  375|       |        // Build the true basic block
  376|    283|        self.builder.position_at_end(true_basic_block);
  377|    283|        self.builder.unconditional_branch(end_basic_block);
  378|       |
  379|       |        // Build the false basic block
  380|    283|        self.builder.position_at_end(false_basic_block);
  381|    283|        self.builder.unconditional_branch(end_basic_block);
  382|       |
  383|       |        // Build the end merger basic block
  384|    283|        self.builder.position_at_end(end_basic_block);
  385|       |
  386|       |        // Create a PHI node to merge the results
  387|    283|        let phi = self.builder.phi(self.int32_type(), "land.phi");
  388|    283|        let true_value = self.const_int(1);
  389|    283|        let false_value = self.const_int(0);
  390|       |
  391|       |        // Add incoming values to the PHI node
  392|    283|        phi.add_incoming(
  393|    283|            &[true_value, false_value],
  394|    283|            &[true_basic_block, false_basic_block],
  395|       |        );
  396|       |
  397|       |        // Append all our new basic blocks to the function
  398|    283|        function.append_existing_basic_block(false_basic_block);
  399|    283|        function.append_existing_basic_block(true_basic_block);
  400|    283|        function.append_existing_basic_block(end_basic_block);
  401|       |
  402|    283|        phi.value()
  403|    283|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen27codegen_binary_greater_than:
  511|    505|    fn codegen_binary_greater_than(&self, left: &Expression, right: &Expression) -> LLVMValue {
  512|    505|        let left_value = self.codegen_expression(left);
  513|    505|        let right_value = self.codegen_expression(right);
  514|       |
  515|    505|        let value = self
  516|    505|            .builder
  517|    505|            .integer_signed_greater_than(left_value, right_value);
  518|    505|        self.builder.zero_extend(value, self.int32_type())
  519|    505|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen33codegen_binary_bitwise_left_shift:
  301|    194|    fn codegen_binary_bitwise_left_shift(
  302|    194|        &self,
  303|    194|        left: &Expression,
  304|    194|        right: &Expression,
  305|    194|    ) -> LLVMValue {
  306|    194|        let left_value = self.codegen_expression(left);
  307|    194|        let right_value = self.codegen_expression(right);
  308|       |
  309|    194|        self.builder.bitwise_left_shift(left_value, right_value)
  310|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen33codegen_binary_less_than_or_equal:
  497|    194|    fn codegen_binary_less_than_or_equal(
  498|    194|        &self,
  499|    194|        left: &Expression,
  500|    194|        right: &Expression,
  501|    194|    ) -> LLVMValue {
  502|    194|        let left_value = self.codegen_expression(left);
  503|    194|        let right_value = self.codegen_expression(right);
  504|       |
  505|    194|        let value = self
  506|    194|            .builder
  507|    194|            .integer_signed_less_than_or_equal(left_value, right_value);
  508|    194|        self.builder.zero_extend(value, self.int32_type())
  509|    194|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen34codegen_binary_bitwise_right_shift:
  319|    200|    fn codegen_binary_bitwise_right_shift(
  320|    200|        &self,
  321|    200|        left: &Expression,
  322|    200|        right: &Expression,
  323|    200|    ) -> LLVMValue {
  324|    200|        let left_value = self.codegen_expression(left);
  325|    200|        let right_value = self.codegen_expression(right);
  326|       |
  327|    200|        self.builder
  328|    200|            .bitwise_arithmetic_right_shift(left_value, right_value)
  329|    200|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen36codegen_binary_greater_than_or_equal:
  521|    218|    fn codegen_binary_greater_than_or_equal(
  522|    218|        &self,
  523|    218|        left: &Expression,
  524|    218|        right: &Expression,
  525|    218|    ) -> LLVMValue {
  526|    218|        let left_value = self.codegen_expression(left);
  527|    218|        let right_value = self.codegen_expression(right);
  528|       |
  529|    218|        let value = self
  530|    218|            .builder
  531|    218|            .integer_signed_greater_than_or_equal(left_value, right_value);
  532|    218|        self.builder.zero_extend(value, self.int32_type())
  533|    218|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen3new:
   48|      1|    pub fn new(file_path: &str) -> Result<Self, CodegenError> {
   49|      1|        let context = LLVMContext::new().ok_or(CodegenError::FailedContextCreation)?;
   50|      1|        let module = LLVMModule::new_in_context(file_path, &context)
   51|      1|            .ok_or(CodegenError::FailedModuleCreation)?;
   52|      1|        let builder =
   53|      1|            LLVMBuilder::new_in_context(&context).ok_or(CodegenError::FailedBuilderCreation)?;
   54|       |
   55|      1|        Ok(Self {
   56|      1|            builder,
   57|      1|            module,
   58|      1|            context,
   59|      1|        })
   60|      1|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen6negate:
  117|    261|    fn negate(&self, value: LLVMValue) -> LLVMValue {
  118|    261|        self.builder.negate(value)
  119|    261|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen7codegen:
  136|  1.31k|    pub fn codegen(&self, translation_unit: &TranslationUnit) {
  137|       |        // Code gen all functions
  138|  2.89k|        for function in &translation_unit.function {
  139|  1.57k|            self.codegen_function(function);
  140|  1.57k|        }
  141|  1.31k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen8function:
   91|  1.57k|    fn function(&self, function_name: &str, function_type: LLVMFunctionType) -> LLVMFunctionValue {
   92|  1.57k|        self.module.add_function(function_name, function_type)
   93|  1.57k|    }
_RNvMs0_CshCskfrbP79Y_14rustcc_codegenNtB5_7Codegen9const_int:
   87|  10.4k|    fn const_int(&self, value: u32) -> LLVMValue {
   88|  10.4k|        self.int32_type().constant_integer(u64::from(value), false)
   89|  10.4k|    }

_RNvYNtNtCshDtJu3Ru83O_5alloc6string6StringNtNtNtCsbetgO7X7nK5_17rustcc_diagnostic5color4shim8Colorize4boldBK_:
   22|  3.74k|        fn bold(self) -> Self {
   23|  3.74k|            self
   24|  3.74k|        }

_RINvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB3_10Diagnostic3newNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeReECsdXdbFklkXPq_12rustcc_lexer:
   87|   147k|    pub fn new<R: Into<SourceRange<'a>>, S: Into<String>>(
   88|   147k|        id: DiagnosticId,
   89|   147k|        source_range: R,
   90|   147k|        message: S,
   91|   147k|    ) -> Self {
   92|   147k|        Self {
   93|   147k|            id,
   94|   147k|            level: id.level(),
   95|   147k|            source_range: source_range.into(),
   96|   147k|            message: message.into(),
   97|   147k|            notes: Vec::new(),
   98|   147k|        }
   99|   147k|    }
_RINvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB3_10Diagnostic3newNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationNtNtCshDtJu3Ru83O_5alloc6string6StringECsdXdbFklkXPq_12rustcc_lexer:
   87|  3.74k|    pub fn new<R: Into<SourceRange<'a>>, S: Into<String>>(
   88|  3.74k|        id: DiagnosticId,
   89|  3.74k|        source_range: R,
   90|  3.74k|        message: S,
   91|  3.74k|    ) -> Self {
   92|  3.74k|        Self {
   93|  3.74k|            id,
   94|  3.74k|            level: id.level(),
   95|  3.74k|            source_range: source_range.into(),
   96|  3.74k|            message: message.into(),
   97|  3.74k|            notes: Vec::new(),
   98|  3.74k|        }
   99|  3.74k|    }
_RINvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB3_10Diagnostic3newNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationReECsdXdbFklkXPq_12rustcc_lexer:
   87|  2.74k|    pub fn new<R: Into<SourceRange<'a>>, S: Into<String>>(
   88|  2.74k|        id: DiagnosticId,
   89|  2.74k|        source_range: R,
   90|  2.74k|        message: S,
   91|  2.74k|    ) -> Self {
   92|  2.74k|        Self {
   93|  2.74k|            id,
   94|  2.74k|            level: id.level(),
   95|  2.74k|            source_range: source_range.into(),
   96|  2.74k|            message: message.into(),
   97|  2.74k|            notes: Vec::new(),
   98|  2.74k|        }
   99|  2.74k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB2_10Diagnostic10is_warning:
  107|   154k|    pub const fn is_warning(&self) -> bool {
  108|   154k|        matches!(self.level, DiagnosticLevel::Warning)
  109|   154k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB2_10Diagnostic14is_fatal_error:
  117|   156k|    pub const fn is_fatal_error(&self) -> bool {
  118|   156k|        matches!(self.level, DiagnosticLevel::FatalError)
  119|   156k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB2_10Diagnostic17is_error_or_fatal:
  122|   154k|    pub const fn is_error_or_fatal(&self) -> bool {
  123|   154k|        self.is_error() || self.is_fatal_error()
  124|   154k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB2_10Diagnostic8is_error:
  112|   154k|    pub const fn is_error(&self) -> bool {
  113|   154k|        matches!(self.level, DiagnosticLevel::Error)
  114|   154k|    }
_RNvMs_NtCsbetgO7X7nK5_17rustcc_diagnostic10diagnosticNtB4_12DiagnosticId5level:
   19|   154k|            pub const fn level(&self) -> DiagnosticLevel {
   20|   154k|                match self {
   21|       |                    $(
   22|       |                        DiagnosticId::$name => $level,
   23|       |                    )*
   24|       |                }
   25|   154k|            }

_RNvXs_NtCsbetgO7X7nK5_17rustcc_diagnostic18diagnostic_builderNtB4_17DiagnosticBuilderNtNtNtCs6SNw0SRvItZ_4core3ops4drop4Drop4drop:
   33|   154k|    fn drop(&mut self) {
   34|   154k|        self.engine.borrow_mut().report(&mut self.diagnostic);
   35|   154k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic18diagnostic_builderNtB2_17DiagnosticBuilder3new:
   16|   154k|    pub const fn new(engine: Rc<RefCell<DiagnosticEngine>>, diagnostic: Diagnostic<'a>) -> Self {
   17|   154k|        Self { engine, diagnostic }
   18|   154k|    }

_RNvXNtCsbetgO7X7nK5_17rustcc_diagnostic19diagnostic_consumerNtB2_24IgnoreDiagnosticConsumerNtB2_18DiagnosticConsumer6report:
   19|   154k|    fn report(&self, _diagnostic: &Diagnostic) {}

_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic17diagnostic_engineNtB2_16DiagnosticEngine3new:
   18|  1.31k|    pub fn new(consumer: Box<dyn DiagnosticConsumer>) -> Self {
   19|  1.31k|        Self {
   20|  1.31k|            number_of_warnings: 0,
   21|  1.31k|            number_of_errors: 0,
   22|  1.31k|            error_limit: 0,
   23|  1.31k|            consumer,
   24|  1.31k|            error_occurred: false,
   25|  1.31k|            fatal_error_occurred: false,
   26|  1.31k|            ignore_all_warnings: false,
   27|  1.31k|            warnings_as_errors: false,
   28|  1.31k|        }
   29|  1.31k|    }
_RNvMNtCsbetgO7X7nK5_17rustcc_diagnostic17diagnostic_engineNtB2_16DiagnosticEngine6report:
   31|   154k|    pub fn report(&mut self, diagnostic: &mut Diagnostic) {
   32|   154k|        if self.ignore_all_warnings {
   33|      0|            diagnostic.ignore_warning();
   34|   154k|        }
   35|       |
   36|   154k|        if self.warnings_as_errors {
   37|      0|            diagnostic.upgrade_warning_to_error();
   38|   154k|        }
   39|       |
   40|   154k|        if diagnostic.is_error_or_fatal() {
   41|   151k|            self.error_occurred = true;
   42|   151k|            self.number_of_errors += 1;
   43|   151k|        }
   44|       |
   45|   154k|        if diagnostic.is_fatal_error() {
   46|      0|            self.fatal_error_occurred = true;
   47|   154k|        }
   48|       |
   49|   154k|        if diagnostic.is_warning() {
   50|  2.30k|            self.number_of_warnings += 1;
   51|   151k|        }
   52|       |
   53|   154k|        self.consumer.report(diagnostic);
   54|   154k|    }

_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer11is_finished:
   74|   163k|    pub const fn is_finished(&self) -> bool {
   75|   163k|        self.index >= self.source_file.content.len()
   76|   163k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer16current_location:
  100|   160k|    fn current_location(&self) -> SourceLocation<'a> {
  101|   160k|        SourceLocation::new(self.source_file, self.index, self.line, self.column)
  102|   160k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer17consume_character:
   90|   144k|    fn consume_character(&mut self) {
   91|       |        // Get current character
   92|       |        #[expect(clippy::unwrap_used)]
   93|   144k|        let current_character = self.peek_next().unwrap();
   94|       |
   95|   144k|        self.column += 1;
   96|   144k|        self.index += current_character.len_utf8();
   97|   144k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer21advance_state_machine:
  128|   161k|    fn advance_state_machine(&mut self) {
  129|   161k|        match self.state {
  130|   114k|            LexerState::Start => match self.peek_next() {
  131|       |                // Whitespaces and newlines
  132|    527|                Some('\n') => {
  133|    527|                    self.consume_character();
  134|    527|
  135|    527|                    self.line += 1;
  136|    527|                    self.column = 1;
  137|    527|                }
  138|   113k|                Some(character) if character.is_whitespace() => {
  139|    994|                    self.consume_character();
  140|    994|                }
  141|       |
  142|   112k|                Some(character) if character.is_ascii_alphabetic() || character == '_' => {
  143|  6.75k|                    self.token_begin_location = self.current_location();
  144|  6.75k|                    self.state = LexerState::Identifier;
  145|  6.75k|                }
  146|   106k|                Some(character) if character.is_ascii_digit() => {
  147|  13.5k|                    self.token_begin_location = self.current_location();
  148|  13.5k|                    self.state = LexerState::IntegerLiteral;
  149|  13.5k|                }
  150|       |
  151|  1.15k|                Some('/') => {
  152|  1.15k|                    self.token_begin_location = self.current_location();
  153|  1.15k|                    self.consume_character();
  154|  1.15k|                    self.state = LexerState::AfterSlash;
  155|  1.15k|                }
  156|       |
  157|       |                // Symbols
  158|  53.3k|                Some('(') => {
  159|  53.3k|                    let location = self.current_location();
  160|  53.3k|
  161|  53.3k|                    self.queued_tokens
  162|  53.3k|                        .push_back(Token::new_left_parenthesis(location));
  163|  53.3k|                    self.consume_character();
  164|  53.3k|                }
  165|  1.32k|                Some(')') => {
  166|  1.32k|                    let location = self.current_location();
  167|  1.32k|
  168|  1.32k|                    self.queued_tokens
  169|  1.32k|                        .push_back(Token::new_right_parenthesis(location));
  170|  1.32k|                    self.consume_character();
  171|  1.32k|                }
  172|    907|                Some('{') => {
  173|    907|                    let location = self.current_location();
  174|    907|
  175|    907|                    self.queued_tokens
  176|    907|                        .push_back(Token::new_left_brace(location));
  177|    907|                    self.consume_character();
  178|    907|                }
  179|    641|                Some('}') => {
  180|    641|                    let location = self.current_location();
  181|    641|
  182|    641|                    self.queued_tokens
  183|    641|                        .push_back(Token::new_right_brace(location));
  184|    641|                    self.consume_character();
  185|    641|                }
  186|  1.99k|                Some(';') => {
  187|  1.99k|                    let location = self.current_location();
  188|  1.99k|
  189|  1.99k|                    self.queued_tokens.push_back(Token::new_semicolon(location));
  190|  1.99k|                    self.consume_character();
  191|  1.99k|                }
  192|  1.10k|                Some('~') => {
  193|  1.10k|                    let location = self.current_location();
  194|  1.10k|
  195|  1.10k|                    self.queued_tokens.push_back(Token::new_tilde(location));
  196|  1.10k|                    self.consume_character();
  197|  1.10k|                }
  198|  1.77k|                Some('-') => {
  199|  1.77k|                    let location = self.current_location();
  200|  1.77k|                    self.token_begin_location = location;
  201|  1.77k|
  202|  1.77k|                    self.state = LexerState::AfterMinus;
  203|  1.77k|                    self.consume_character();
  204|  1.77k|                }
  205|  2.74k|                Some('+') => {
  206|  2.74k|                    self.token_begin_location = self.current_location();
  207|  2.74k|
  208|  2.74k|                    self.state = LexerState::AfterPlus;
  209|  2.74k|                    self.consume_character();
  210|  2.74k|                }
  211|  1.11k|                Some('*') => {
  212|  1.11k|                    let location = self.current_location();
  213|  1.11k|
  214|  1.11k|                    self.queued_tokens.push_back(Token::new_star(location));
  215|  1.11k|                    self.consume_character();
  216|  1.11k|                }
  217|  1.08k|                Some('%') => {
  218|  1.08k|                    let location = self.current_location();
  219|  1.08k|
  220|  1.08k|                    self.queued_tokens.push_back(Token::new_percent(location));
  221|  1.08k|                    self.consume_character();
  222|  1.08k|                }
  223|  1.44k|                Some('&') => {
  224|  1.44k|                    let location = self.current_location();
  225|  1.44k|                    self.token_begin_location = location;
  226|  1.44k|
  227|  1.44k|                    self.state = LexerState::AfterAmpersand;
  228|  1.44k|                    self.consume_character();
  229|  1.44k|                }
  230|  1.55k|                Some('|') => {
  231|  1.55k|                    let location = self.current_location();
  232|  1.55k|                    self.token_begin_location = location;
  233|  1.55k|
  234|  1.55k|                    self.state = LexerState::AfterPipe;
  235|  1.55k|                    self.consume_character();
  236|  1.55k|                }
  237|    800|                Some('^') => {
  238|    800|                    let location = self.current_location();
  239|    800|
  240|    800|                    self.queued_tokens.push_back(Token::new_caret(location));
  241|    800|                    self.consume_character();
  242|    800|                }
  243|  2.47k|                Some('<') => {
  244|  2.47k|                    let location = self.current_location();
  245|  2.47k|                    self.token_begin_location = location;
  246|  2.47k|
  247|  2.47k|                    self.state = LexerState::AfterLessThan;
  248|  2.47k|                    self.consume_character();
  249|  2.47k|                }
  250|  2.66k|                Some('>') => {
  251|  2.66k|                    let location = self.current_location();
  252|  2.66k|                    self.token_begin_location = location;
  253|  2.66k|
  254|  2.66k|                    self.state = LexerState::AfterGreaterThan;
  255|  2.66k|                    self.consume_character();
  256|  2.66k|                }
  257|  1.98k|                Some('=') => {
  258|  1.98k|                    let location = self.current_location();
  259|  1.98k|                    self.token_begin_location = location;
  260|  1.98k|
  261|  1.98k|                    self.state = LexerState::AfterEquals;
  262|  1.98k|                    self.consume_character();
  263|  1.98k|                }
  264|  8.59k|                Some('!') => {
  265|  8.59k|                    let location = self.current_location();
  266|  8.59k|                    self.token_begin_location = location;
  267|  8.59k|
  268|  8.59k|                    self.state = LexerState::AfterBang;
  269|  8.59k|                    self.consume_character();
  270|  8.59k|                }
  271|       |
  272|  2.30k|                Some('\0') => {
  273|  2.30k|                    self.diagnostic_here(DiagnosticId::NullCharacter, "null character ignored");
  274|  2.30k|
  275|  2.30k|                    self.consume_character();
  276|  2.30k|                }
  277|       |
  278|      0|                None => {}
  279|       |
  280|  3.74k|                Some(character) => {
  281|  3.74k|                    self.diagnostic_here(
  282|  3.74k|                        DiagnosticId::UnexpectedCharacter,
  283|  3.74k|                        format!(
  284|  3.74k|                            "unexpected character '{}' found",
  285|  3.74k|                            character.to_string().bold()
  286|  3.74k|                        ),
  287|  3.74k|                    );
  288|  3.74k|
  289|  3.74k|                    self.consume_character();
  290|  3.74k|                }
  291|       |            },
  292|       |
  293|       |            LexerState::Identifier => loop {
  294|  31.1k|                match self.peek_next() {
  295|  30.9k|                    Some(character) if character.is_ascii_alphanumeric() || character == '_' => {
  296|  24.3k|                        self.token_end_location = self.current_location();
  297|  24.3k|                        self.consume_character();
  298|  24.3k|                    }
  299|       |                    _ => {
  300|       |                        // Emit identifier token
  301|  6.75k|                        let token = Token::new_identifier(SourceRange::new(
  302|  6.75k|                            self.token_begin_location,
  303|  6.75k|                            self.token_end_location,
  304|       |                        ));
  305|  6.75k|                        self.queued_tokens.push_back(token);
  306|       |
  307|  6.75k|                        self.state = LexerState::Start;
  308|  6.75k|                        break;
  309|       |                    }
  310|       |                }
  311|       |            },
  312|       |
  313|       |            LexerState::IntegerLiteral => {
  314|  13.5k|                let mut value: u32 = 0;
  315|       |                loop {
  316|  30.6k|                    match self.peek_next() {
  317|  30.5k|                        Some(character) if character.is_ascii_digit() => {
  318|       |                            // Multiply the current value by 10 and check for
  319|       |                            // any overflow
  320|  17.5k|                            let Some(temp_value) = value.checked_mul(10) else {
  321|    226|                                self.state = LexerState::IntegerLiteralOverflow;
  322|    226|                                break;
  323|       |                            };
  324|       |
  325|       |                            // Convert the current character to an actual base
  326|       |                            // 10 number
  327|       |                            #[expect(clippy::unwrap_used)]
  328|  17.3k|                            let character_value = character.to_digit(10).unwrap();
  329|       |
  330|       |                            // Add the current character value to the current
  331|       |                            // value and check for any overflow
  332|  17.3k|                            let Some(temp_value) = temp_value.checked_add(character_value) else {
  333|    194|                                self.state = LexerState::IntegerLiteralOverflow;
  334|    194|                                break;
  335|       |                            };
  336|       |
  337|       |                            // Update the current value and consume the
  338|       |                            // character
  339|  17.1k|                            value = temp_value;
  340|  17.1k|                            self.token_end_location = self.current_location();
  341|  17.1k|                            self.consume_character();
  342|       |                        }
  343|       |                        _ => {
  344|  13.0k|                            let token = Token::new_integer_literal(
  345|  13.0k|                                value,
  346|  13.0k|                                SourceRange::new(
  347|  13.0k|                                    self.token_begin_location,
  348|  13.0k|                                    self.token_end_location,
  349|       |                                ),
  350|       |                            );
  351|       |
  352|  13.0k|                            self.queued_tokens.push_back(token);
  353|  13.0k|                            self.state = LexerState::Start;
  354|  13.0k|                            break;
  355|       |                        }
  356|       |                    }
  357|       |                }
  358|       |            }
  359|       |
  360|       |            LexerState::IntegerLiteralOverflow => {
  361|       |                loop {
  362|  1.06k|                    match self.peek_next() {
  363|  1.05k|                        Some(character) if character.is_ascii_digit() => {
  364|    643|                            // Consume all digit characters until we reach a
  365|    643|                            // non-digit character
  366|    643|                            self.token_end_location = self.current_location();
  367|    643|                            self.consume_character();
  368|    643|                        }
  369|       |                        _ => {
  370|    420|                            self.diagnostic(
  371|    420|                                DiagnosticId::IntegerLiteralTooLarge,
  372|    420|                                SourceRange::new(
  373|    420|                                    self.token_begin_location,
  374|    420|                                    self.token_end_location,
  375|       |                                ),
  376|       |                                "integer literal is too large",
  377|       |                            );
  378|       |
  379|    420|                            self.state = LexerState::Start;
  380|    420|                            break;
  381|       |                        }
  382|       |                    }
  383|       |                }
  384|       |            }
  385|       |
  386|       |            LexerState::AfterSlash => {
  387|  1.14k|                match self.peek_next() {
  388|    226|                    Some('/') => {
  389|    226|                        // Two slashes in a row, the rest of the line thus is a
  390|    226|                        // comment
  391|    226|                        self.consume_character();
  392|    226|                        self.state = LexerState::LineComment;
  393|    226|                    }
  394|    237|                    Some('*') => {
  395|    237|                        // Start of a multi-line comment
  396|    237|                        self.consume_character();
  397|    237|                        self.state = LexerState::MultiLineComment;
  398|    237|                    }
  399|       |
  400|    685|                    Some(_) => {
  401|    685|                        self.queued_tokens
  402|    685|                            .push_back(Token::new_slash(self.token_begin_location));
  403|    685|
  404|    685|                        self.state = LexerState::Start;
  405|    685|                    }
  406|       |
  407|      0|                    None => {
  408|      0|                        self.queued_tokens
  409|      0|                            .push_back(Token::new_slash(self.token_begin_location));
  410|      0|                    }
  411|       |                }
  412|       |            }
  413|       |
  414|    809|            LexerState::LineComment => match self.peek_next() {
  415|    199|                Some('\n') => {
  416|    199|                    self.consume_character();
  417|    199|
  418|    199|                    self.line += 1;
  419|    199|                    self.column = 1;
  420|    199|
  421|    199|                    self.state = LexerState::Start;
  422|    199|                }
  423|       |
  424|    610|                Some(_) => {
  425|    610|                    self.consume_character();
  426|    610|                }
  427|       |
  428|      0|                None => {}
  429|       |            },
  430|       |
  431|  1.08k|            LexerState::MultiLineComment => match self.peek_next() {
  432|    608|                Some('*') => {
  433|    608|                    self.consume_character();
  434|    608|                    self.state = LexerState::MultiLineCommentAfterStar;
  435|    608|                }
  436|       |
  437|    205|                Some('\n') => {
  438|    205|                    self.consume_character();
  439|    205|
  440|    205|                    self.line += 1;
  441|    205|                    self.column = 1;
  442|    205|                }
  443|       |
  444|    273|                Some(_) => {
  445|    273|                    self.consume_character();
  446|    273|                }
  447|       |
  448|      0|                None => {
  449|      0|                    // TODO: This is an untermianted multiline comment error
  450|      0|                }
  451|       |            },
  452|       |
  453|       |            LexerState::MultiLineCommentAfterStar => {
  454|    607|                match self.peek_next() {
  455|    198|                    Some('/') => {
  456|    198|                        // */ Indicates the end of the multi-line comment
  457|    198|                        self.consume_character();
  458|    198|                        self.state = LexerState::Start;
  459|    198|                    }
  460|       |
  461|    199|                    Some('\n') => {
  462|    199|                        self.consume_character();
  463|    199|
  464|    199|                        self.line += 1;
  465|    199|                        self.column = 1;
  466|    199|
  467|    199|                        self.state = LexerState::MultiLineComment;
  468|    199|                    }
  469|       |
  470|    210|                    Some(_) => {
  471|    210|                        self.consume_character();
  472|    210|                        self.state = LexerState::MultiLineComment;
  473|    210|                    }
  474|       |
  475|      0|                    None => {
  476|      0|                        // TODO: This is an unterminated multipline comment
  477|      0|                        // error
  478|      0|                    }
  479|       |                }
  480|       |            }
  481|       |
  482|  1.76k|            LexerState::AfterMinus => match self.peek_next() {
  483|    229|                Some('-') => {
  484|    229|                    let location =
  485|    229|                        SourceRange::new(self.token_begin_location, self.current_location());
  486|    229|
  487|    229|                    self.consume_character();
  488|    229|                    self.queued_tokens
  489|    229|                        .push_back(Token::new_minus_minus(location));
  490|    229|
  491|    229|                    self.state = LexerState::Start;
  492|    229|                }
  493|       |
  494|  1.54k|                Some(_) => {
  495|  1.54k|                    self.queued_tokens
  496|  1.54k|                        .push_back(Token::new_minus(self.token_begin_location));
  497|  1.54k|
  498|  1.54k|                    self.state = LexerState::Start;
  499|  1.54k|                }
  500|       |
  501|      0|                None => {
  502|      0|                    let location =
  503|      0|                        SourceRange::new(self.token_begin_location, self.current_location());
  504|      0|                    self.queued_tokens.push_back(Token::new_minus(location));
  505|      0|                }
  506|       |            },
  507|       |
  508|  2.73k|            LexerState::AfterPlus => match self.peek_next() {
  509|    275|                Some('+') => {
  510|    275|                    let location =
  511|    275|                        SourceRange::new(self.token_begin_location, self.current_location());
  512|    275|
  513|    275|                    self.consume_character();
  514|    275|                    self.queued_tokens.push_back(Token::new_plus_plus(location));
  515|    275|
  516|    275|                    self.state = LexerState::Start;
  517|    275|                }
  518|       |
  519|  2.45k|                _ => {
  520|  2.45k|                    self.queued_tokens
  521|  2.45k|                        .push_back(Token::new_plus(self.token_begin_location));
  522|  2.45k|
  523|  2.45k|                    self.state = LexerState::Start;
  524|  2.45k|                }
  525|       |            },
  526|       |
  527|  2.46k|            LexerState::AfterLessThan => match self.peek_next() {
  528|    460|                Some('=') => {
  529|    460|                    let location =
  530|    460|                        SourceRange::new(self.token_begin_location, self.current_location());
  531|    460|
  532|    460|                    self.consume_character();
  533|    460|                    self.queued_tokens
  534|    460|                        .push_back(Token::new_less_than_equal(location));
  535|    460|
  536|    460|                    self.state = LexerState::Start;
  537|    460|                }
  538|    647|                Some('<') => {
  539|    647|                    let location =
  540|    647|                        SourceRange::new(self.token_begin_location, self.current_location());
  541|    647|
  542|    647|                    self.consume_character();
  543|    647|                    self.queued_tokens
  544|    647|                        .push_back(Token::new_less_than_less_than(location));
  545|    647|
  546|    647|                    self.state = LexerState::Start;
  547|    647|                }
  548|       |
  549|  1.35k|                _ => {
  550|  1.35k|                    self.queued_tokens
  551|  1.35k|                        .push_back(Token::new_less_than(self.token_begin_location));
  552|  1.35k|
  553|  1.35k|                    self.state = LexerState::Start;
  554|  1.35k|                }
  555|       |            },
  556|       |
  557|  2.66k|            LexerState::AfterGreaterThan => match self.peek_next() {
  558|    442|                Some('=') => {
  559|    442|                    let location =
  560|    442|                        SourceRange::new(self.token_begin_location, self.current_location());
  561|    442|
  562|    442|                    self.consume_character();
  563|    442|                    self.queued_tokens
  564|    442|                        .push_back(Token::new_greater_than_equal(location));
  565|    442|
  566|    442|                    self.state = LexerState::Start;
  567|    442|                }
  568|    526|                Some('>') => {
  569|    526|                    let location =
  570|    526|                        SourceRange::new(self.token_begin_location, self.current_location());
  571|    526|
  572|    526|                    self.consume_character();
  573|    526|                    self.queued_tokens
  574|    526|                        .push_back(Token::new_greater_than_greater_than(location));
  575|    526|
  576|    526|                    self.state = LexerState::Start;
  577|    526|                }
  578|       |
  579|  1.69k|                _ => {
  580|  1.69k|                    self.queued_tokens
  581|  1.69k|                        .push_back(Token::new_greater_than(self.token_begin_location));
  582|  1.69k|
  583|  1.69k|                    self.state = LexerState::Start;
  584|  1.69k|                }
  585|       |            },
  586|       |
  587|  1.44k|            LexerState::AfterAmpersand => match self.peek_next() {
  588|    606|                Some('&') => {
  589|    606|                    let location =
  590|    606|                        SourceRange::new(self.token_begin_location, self.current_location());
  591|    606|
  592|    606|                    self.consume_character();
  593|    606|                    self.queued_tokens
  594|    606|                        .push_back(Token::new_ampersand_ampersand(location));
  595|    606|
  596|    606|                    self.state = LexerState::Start;
  597|    606|                }
  598|       |
  599|    841|                _ => {
  600|    841|                    self.queued_tokens
  601|    841|                        .push_back(Token::new_ampersand(self.token_begin_location));
  602|    841|
  603|    841|                    self.state = LexerState::Start;
  604|    841|                }
  605|       |            },
  606|       |
  607|  1.54k|            LexerState::AfterPipe => match self.peek_next() {
  608|    561|                Some('|') => {
  609|    561|                    let location =
  610|    561|                        SourceRange::new(self.token_begin_location, self.current_location());
  611|    561|
  612|    561|                    self.consume_character();
  613|    561|                    self.queued_tokens.push_back(Token::new_pipe_pipe(location));
  614|    561|
  615|    561|                    self.state = LexerState::Start;
  616|    561|                }
  617|       |
  618|    984|                _ => {
  619|    984|                    self.queued_tokens
  620|    984|                        .push_back(Token::new_pipe(self.token_begin_location));
  621|    984|
  622|    984|                    self.state = LexerState::Start;
  623|    984|                }
  624|       |            },
  625|       |
  626|  8.56k|            LexerState::AfterBang => match self.peek_next() {
  627|    523|                Some('=') => {
  628|    523|                    let location =
  629|    523|                        SourceRange::new(self.token_begin_location, self.current_location());
  630|    523|
  631|    523|                    self.consume_character();
  632|    523|                    self.queued_tokens
  633|    523|                        .push_back(Token::new_bang_equals(location));
  634|    523|
  635|    523|                    self.state = LexerState::Start;
  636|    523|                }
  637|       |
  638|  8.04k|                _ => {
  639|  8.04k|                    self.queued_tokens
  640|  8.04k|                        .push_back(Token::new_bang(self.token_begin_location));
  641|  8.04k|
  642|  8.04k|                    self.state = LexerState::Start;
  643|  8.04k|                }
  644|       |            },
  645|       |
  646|  1.98k|            LexerState::AfterEquals => match self.peek_next() {
  647|    732|                Some('=') => {
  648|    732|                    let location =
  649|    732|                        SourceRange::new(self.token_begin_location, self.current_location());
  650|    732|
  651|    732|                    self.consume_character();
  652|    732|                    self.queued_tokens
  653|    732|                        .push_back(Token::new_equals_equals(location));
  654|    732|
  655|    732|                    self.state = LexerState::Start;
  656|    732|                }
  657|       |
  658|  1.24k|                _ => {
  659|  1.24k|                    self.queued_tokens
  660|  1.24k|                        .push_back(Token::new_equals(self.token_begin_location));
  661|  1.24k|
  662|  1.24k|                    self.state = LexerState::Start;
  663|  1.24k|                }
  664|       |            },
  665|       |        }
  666|   161k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer3new:
   56|  1.31k|    pub const fn new(
   57|  1.31k|        diagnostic_engine: Rc<RefCell<DiagnosticEngine>>,
   58|  1.31k|        source_file: &'a SourceFile,
   59|  1.31k|    ) -> Self {
   60|  1.31k|        Self {
   61|  1.31k|            state: LexerState::Start,
   62|  1.31k|            diagnostic_engine,
   63|  1.31k|            source_file,
   64|  1.31k|            line: 1,
   65|  1.31k|            column: 1,
   66|  1.31k|            index: 0,
   67|  1.31k|            token_begin_location: SourceLocation::invalid(),
   68|  1.31k|            token_end_location: SourceLocation::invalid(),
   69|  1.31k|            queued_tokens: TokenList::new(),
   70|  1.31k|        }
   71|  1.31k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer8tokenize:
   78|  1.31k|    pub fn tokenize(&'_ mut self) -> TokenList<'_> {
   79|   163k|        while !self.is_finished() {
   80|   161k|            self.advance_state_machine();
   81|   161k|        }
   82|       |
   83|  1.31k|        self.queued_tokens.drain(..).collect()
   84|  1.31k|    }
_RNvMCsdXdbFklkXPq_12rustcc_lexerNtB2_5Lexer9peek_next:
   86|   348k|    fn peek_next(&self) -> Option<char> {
   87|   348k|        self.source_file.content[self.index..].chars().next()
   88|   348k|    }
_RINvMCsdXdbFklkXPq_12rustcc_lexerNtB3_5Lexer10diagnosticNtNtCshDtJu3Ru83O_5alloc6string6StringNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB3_:
  104|  3.74k|    fn diagnostic<S: Into<String>, R: Into<SourceRange<'a>>>(
  105|  3.74k|        &'_ self,
  106|  3.74k|        id: DiagnosticId,
  107|  3.74k|        source_range: R,
  108|  3.74k|        message: S,
  109|  3.74k|    ) -> DiagnosticBuilder<'_> {
  110|  3.74k|        let diagnostic = Diagnostic::new(id, source_range, message);
  111|       |
  112|  3.74k|        DiagnosticBuilder::new(self.diagnostic_engine.clone(), diagnostic)
  113|  3.74k|    }
_RINvMCsdXdbFklkXPq_12rustcc_lexerNtB3_5Lexer10diagnosticReNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB3_:
  104|    420|    fn diagnostic<S: Into<String>, R: Into<SourceRange<'a>>>(
  105|    420|        &'_ self,
  106|    420|        id: DiagnosticId,
  107|    420|        source_range: R,
  108|    420|        message: S,
  109|    420|    ) -> DiagnosticBuilder<'_> {
  110|    420|        let diagnostic = Diagnostic::new(id, source_range, message);
  111|       |
  112|    420|        DiagnosticBuilder::new(self.diagnostic_engine.clone(), diagnostic)
  113|    420|    }
_RINvMCsdXdbFklkXPq_12rustcc_lexerNtB3_5Lexer10diagnosticReNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB3_:
  104|  2.30k|    fn diagnostic<S: Into<String>, R: Into<SourceRange<'a>>>(
  105|  2.30k|        &'_ self,
  106|  2.30k|        id: DiagnosticId,
  107|  2.30k|        source_range: R,
  108|  2.30k|        message: S,
  109|  2.30k|    ) -> DiagnosticBuilder<'_> {
  110|  2.30k|        let diagnostic = Diagnostic::new(id, source_range, message);
  111|       |
  112|  2.30k|        DiagnosticBuilder::new(self.diagnostic_engine.clone(), diagnostic)
  113|  2.30k|    }
_RINvMCsdXdbFklkXPq_12rustcc_lexerNtB3_5Lexer15diagnostic_hereNtNtCshDtJu3Ru83O_5alloc6string6StringEB3_:
  115|  3.74k|    fn diagnostic_here<S: Into<String>>(
  116|  3.74k|        &'_ self,
  117|  3.74k|        id: DiagnosticId,
  118|  3.74k|        message: S,
  119|  3.74k|    ) -> DiagnosticBuilder<'_> {
  120|  3.74k|        let location = self.current_location();
  121|       |
  122|  3.74k|        self.diagnostic(id, location, message)
  123|  3.74k|    }
_RINvMCsdXdbFklkXPq_12rustcc_lexerNtB3_5Lexer15diagnostic_hereReEB3_:
  115|  2.30k|    fn diagnostic_here<S: Into<String>>(
  116|  2.30k|        &'_ self,
  117|  2.30k|        id: DiagnosticId,
  118|  2.30k|        message: S,
  119|  2.30k|    ) -> DiagnosticBuilder<'_> {
  120|  2.30k|        let location = self.current_location();
  121|       |
  122|  2.30k|        self.diagnostic(id, location, message)
  123|  2.30k|    }

_RNvMNtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB2_9TokenKind13is_identifier:
   71|  21.5k|    pub const fn is_identifier(&self) -> bool {
   72|  21.5k|        matches!(self, Self::Identifier(_))
   73|  21.5k|    }
_RNvMNtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB2_9TokenKind14unary_operator:
  135|  7.70k|    pub const fn unary_operator(&self) -> Option<UnaryOperator> {
  136|       |        #[expect(clippy::wildcard_enum_match_arm)]
  137|  7.70k|        match self {
  138|    385|            Self::Plus => Some(UnaryOperator::Positive),
  139|    328|            Self::Minus => Some(UnaryOperator::Negate),
  140|    757|            Self::Tilde => Some(UnaryOperator::Complement),
  141|  6.23k|            Self::Bang => Some(UnaryOperator::LogicalNot),
  142|       |
  143|      0|            _ => None,
  144|       |        }
  145|  7.70k|    }
_RNvMNtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB2_9TokenKind15binary_operator:
  107|  18.7k|    pub const fn binary_operator(&self) -> Option<BinaryOperator> {
  108|       |        #[expect(clippy::wildcard_enum_match_arm)]
  109|  18.7k|        match self {
  110|    880|            Self::Plus => Some(BinaryOperator::Add),
  111|    712|            Self::Minus => Some(BinaryOperator::Subtract),
  112|    804|            Self::Star => Some(BinaryOperator::Multiply),
  113|    607|            Self::Slash => Some(BinaryOperator::Divide),
  114|    796|            Self::Percent => Some(BinaryOperator::Remainder),
  115|    629|            Self::Ampersand => Some(BinaryOperator::BitwiseAnd),
  116|    578|            Self::AmpersandAmpersand => Some(BinaryOperator::LogicalAnd),
  117|    646|            Self::Caret => Some(BinaryOperator::BitwiseXor),
  118|    974|            Self::Pipe => Some(BinaryOperator::BitwiseOr),
  119|    630|            Self::PipePipe => Some(BinaryOperator::LogicalOr),
  120|    790|            Self::Equals => Some(BinaryOperator::Assignment),
  121|    806|            Self::EqualsEquals => Some(BinaryOperator::Equals),
  122|    562|            Self::BangEquals => Some(BinaryOperator::NotEquals),
  123|    820|            Self::LessThan => Some(BinaryOperator::LessThan),
  124|    559|            Self::LessThanEqual => Some(BinaryOperator::LessThanOrEqual),
  125|    649|            Self::LessThanLessThan => Some(BinaryOperator::BitwiseLeftShift),
  126|  1.17k|            Self::GreaterThan => Some(BinaryOperator::GreaterThan),
  127|    467|            Self::GreaterThanEqual => Some(BinaryOperator::GreaterThanOrEqual),
  128|    502|            Self::GreaterThanGreaterThan => Some(BinaryOperator::BitwiseRightShift),
  129|       |
  130|  5.11k|            _ => None,
  131|       |        }
  132|  18.7k|    }
_RNvMNtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB2_9TokenKind15from_identifier:
   53|  6.75k|    pub fn from_identifier(identifier: &str) -> Self {
   54|  6.75k|        match identifier {
   55|  6.75k|            "int" => Self::KeywordInt,
   56|  6.55k|            "return" => Self::KeywordReturn,
   57|  3.71k|            "void" => Self::KeywordVoid,
   58|  3.51k|            _ => Self::Identifier(identifier.to_owned()),
   59|       |        }
   60|  6.75k|    }
_RNvMNtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB2_9TokenKind17is_unary_operator:
  102|  59.1k|    pub const fn is_unary_operator(&self) -> bool {
  103|  59.1k|        matches!(self, Self::Plus | Self::Minus | Self::Tilde | Self::Bang)
  104|  59.1k|    }
_RNvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB4_5Token13is_identifier:
  517|  21.5k|    pub const fn is_identifier(&self) -> bool {
  518|  21.5k|        self.kind.is_identifier()
  519|  21.5k|    }
_RNvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB4_5Token14unary_operator:
  537|  7.70k|    pub const fn unary_operator(&self) -> Option<UnaryOperator> {
  538|  7.70k|        self.kind.unary_operator()
  539|  7.70k|    }
_RNvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB4_5Token15binary_operator:
  532|  18.7k|    pub const fn binary_operator(&self) -> Option<BinaryOperator> {
  533|  18.7k|        self.kind.binary_operator()
  534|  18.7k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token10new_equalsNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  398|  1.24k|    pub fn new_equals<R: Into<SourceRange<'a>>>(range: R) -> Self {
  399|  1.24k|        let range = range.into();
  400|       |
  401|  1.24k|        debug_assert_eq!(range.source_text().unwrap_or(""), "=", "Expected '='");
  402|       |
  403|  1.24k|        Self {
  404|  1.24k|            kind: TokenKind::Equals,
  405|  1.24k|            range,
  406|  1.24k|        }
  407|  1.24k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token11new_percentNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  326|  1.08k|    pub fn new_percent<R: Into<SourceRange<'a>>>(range: R) -> Self {
  327|  1.08k|        let range = range.into();
  328|       |
  329|  1.08k|        debug_assert_eq!(range.source_text().unwrap_or(""), "%", "Expected '%'");
  330|       |
  331|  1.08k|        Self {
  332|  1.08k|            kind: TokenKind::Percent,
  333|  1.08k|            range,
  334|  1.08k|        }
  335|  1.08k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token13new_ampersandNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  338|    841|    pub fn new_ampersand<R: Into<SourceRange<'a>>>(range: R) -> Self {
  339|    841|        let range = range.into();
  340|       |
  341|    841|        debug_assert_eq!(range.source_text().unwrap_or(""), "&", "Expected '&'");
  342|       |
  343|    841|        Self {
  344|    841|            kind: TokenKind::Ampersand,
  345|    841|            range,
  346|    841|        }
  347|    841|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token13new_less_thanNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  445|  1.35k|    pub fn new_less_than<R: Into<SourceRange<'a>>>(range: R) -> Self {
  446|  1.35k|        let range = range.into();
  447|       |
  448|  1.35k|        debug_assert_eq!(range.source_text().unwrap_or(""), "<", "Expected '<'");
  449|       |
  450|  1.35k|        Self {
  451|  1.35k|            kind: TokenKind::LessThan,
  452|  1.35k|            range,
  453|  1.35k|        }
  454|  1.35k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token13new_pipe_pipeNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  386|    561|    pub fn new_pipe_pipe<R: Into<SourceRange<'a>>>(range: R) -> Self {
  387|    561|        let range = range.into();
  388|       |
  389|    561|        debug_assert_eq!(range.source_text().unwrap_or(""), "||", "Expected '||'");
  390|       |
  391|    561|        Self {
  392|    561|            kind: TokenKind::PipePipe,
  393|    561|            range,
  394|    561|        }
  395|    561|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token13new_plus_plusNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  302|    275|    pub fn new_plus_plus<R: Into<SourceRange<'a>>>(range: R) -> Self {
  303|    275|        let range = range.into();
  304|       |
  305|    275|        debug_assert_eq!(range.source_text().unwrap_or(""), "++", "Expected '++'");
  306|       |
  307|    275|        Self {
  308|    275|            kind: TokenKind::PlusPlus,
  309|    275|            range,
  310|    275|        }
  311|    275|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token13new_semicolonNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  230|  1.99k|    pub fn new_semicolon<R: Into<SourceRange<'a>>>(range: R) -> Self {
  231|  1.99k|        let range = range.into();
  232|       |
  233|  1.99k|        debug_assert_eq!(range.source_text().unwrap_or(""), ";", "Expected ';'");
  234|       |
  235|  1.99k|        Self {
  236|  1.99k|            kind: TokenKind::Semicolon,
  237|  1.99k|            range,
  238|  1.99k|        }
  239|  1.99k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token14new_identifierNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  161|  6.75k|    pub fn new_identifier<R: Into<SourceRange<'a>>>(range: R) -> Self {
  162|  6.75k|        let range = range.into();
  163|       |
  164|  6.75k|        let source_text = range.source_text().unwrap_or("");
  165|  6.75k|        assert!(!source_text.is_empty(), "Identifier cannot be empty");
  166|       |
  167|  6.75k|        Self {
  168|  6.75k|            kind: TokenKind::from_identifier(source_text),
  169|  6.75k|            range,
  170|  6.75k|        }
  171|  6.75k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token14new_left_braceNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  206|    907|    pub fn new_left_brace<R: Into<SourceRange<'a>>>(range: R) -> Self {
  207|    907|        let range = range.into();
  208|       |
  209|    907|        debug_assert_eq!(range.source_text().unwrap_or(""), "{", "Expected '{{'");
  210|       |
  211|    907|        Self {
  212|    907|            kind: TokenKind::LeftBrace,
  213|    907|            range,
  214|    907|        }
  215|    907|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token15new_bang_equalsNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  434|    523|    pub fn new_bang_equals<R: Into<SourceRange<'a>>>(range: R) -> Self {
  435|    523|        let range = range.into();
  436|       |
  437|    523|        debug_assert_eq!(range.source_text().unwrap_or(""), "!=", "Expected '!='");
  438|       |
  439|    523|        Self {
  440|    523|            kind: TokenKind::BangEquals,
  441|    523|            range,
  442|    523|        }
  443|    523|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token15new_minus_minusNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  278|    229|    pub fn new_minus_minus<R: Into<SourceRange<'a>>>(range: R) -> Self {
  279|    229|        let range = range.into();
  280|       |
  281|    229|        debug_assert_eq!(range.source_text().unwrap_or(""), "--", "Expected '--'");
  282|       |
  283|    229|        Self {
  284|    229|            kind: TokenKind::MinusMinus,
  285|    229|            range,
  286|    229|        }
  287|    229|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token15new_right_braceNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  218|    641|    pub fn new_right_brace<R: Into<SourceRange<'a>>>(range: R) -> Self {
  219|    641|        let range = range.into();
  220|       |
  221|    641|        debug_assert_eq!(range.source_text().unwrap_or(""), "}", "Expected '}}'");
  222|       |
  223|    641|        Self {
  224|    641|            kind: TokenKind::RightBrace,
  225|    641|            range,
  226|    641|        }
  227|    641|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token16new_greater_thanNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  478|  1.69k|    pub fn new_greater_than<R: Into<SourceRange<'a>>>(range: R) -> Self {
  479|  1.69k|        let range = range.into();
  480|       |
  481|  1.69k|        debug_assert_eq!(range.source_text().unwrap_or(""), ">", "Expected '>'");
  482|       |
  483|  1.69k|        Self {
  484|  1.69k|            kind: TokenKind::GreaterThan,
  485|  1.69k|            range,
  486|  1.69k|        }
  487|  1.69k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token17new_equals_equalsNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  410|    732|    pub fn new_equals_equals<R: Into<SourceRange<'a>>>(range: R) -> Self {
  411|    732|        let range = range.into();
  412|       |
  413|    732|        debug_assert_eq!(range.source_text().unwrap_or(""), "==", "Expected '=='");
  414|       |
  415|    732|        Self {
  416|    732|            kind: TokenKind::EqualsEquals,
  417|    732|            range,
  418|    732|        }
  419|    732|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token19new_integer_literalNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  174|  13.0k|    pub fn new_integer_literal<R: Into<SourceRange<'a>>>(value: u32, range: R) -> Self {
  175|  13.0k|        Self {
  176|  13.0k|            kind: TokenKind::IntegerLiteral(value),
  177|  13.0k|            range: range.into(),
  178|  13.0k|        }
  179|  13.0k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token19new_less_than_equalNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  456|    460|    pub fn new_less_than_equal<R: Into<SourceRange<'a>>>(range: R) -> Self {
  457|    460|        let range = range.into();
  458|       |
  459|    460|        debug_assert_eq!(range.source_text().unwrap_or(""), "<=", "Expected '<='");
  460|       |
  461|    460|        Self {
  462|    460|            kind: TokenKind::LessThanEqual,
  463|    460|            range,
  464|    460|        }
  465|    460|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token20new_left_parenthesisNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  182|  53.3k|    pub fn new_left_parenthesis<R: Into<SourceRange<'a>>>(range: R) -> Self {
  183|  53.3k|        let range = range.into();
  184|       |
  185|  53.3k|        debug_assert_eq!(range.source_text().unwrap_or(""), "(", "Expected '('");
  186|       |
  187|  53.3k|        Self {
  188|  53.3k|            kind: TokenKind::LeftParenthesis,
  189|  53.3k|            range,
  190|  53.3k|        }
  191|  53.3k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token21new_right_parenthesisNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  194|  1.32k|    pub fn new_right_parenthesis<R: Into<SourceRange<'a>>>(range: R) -> Self {
  195|  1.32k|        let range = range.into();
  196|       |
  197|  1.32k|        debug_assert_eq!(range.source_text().unwrap_or(""), ")", "Expected ')'");
  198|       |
  199|  1.32k|        Self {
  200|  1.32k|            kind: TokenKind::RightParenthesis,
  201|  1.32k|            range,
  202|  1.32k|        }
  203|  1.32k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token22new_greater_than_equalNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  489|    442|    pub fn new_greater_than_equal<R: Into<SourceRange<'a>>>(range: R) -> Self {
  490|    442|        let range = range.into();
  491|       |
  492|    442|        debug_assert_eq!(range.source_text().unwrap_or(""), ">=", "Expected '>='");
  493|       |
  494|    442|        Self {
  495|    442|            kind: TokenKind::GreaterThanEqual,
  496|    442|            range,
  497|    442|        }
  498|    442|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token23new_ampersand_ampersandNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  350|    606|    pub fn new_ampersand_ampersand<R: Into<SourceRange<'a>>>(range: R) -> Self {
  351|    606|        let range = range.into();
  352|       |
  353|    606|        debug_assert_eq!(range.source_text().unwrap_or(""), "&&", "Expected '&&'");
  354|       |
  355|    606|        Self {
  356|    606|            kind: TokenKind::AmpersandAmpersand,
  357|    606|            range,
  358|    606|        }
  359|    606|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token23new_less_than_less_thanNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  467|    647|    pub fn new_less_than_less_than<R: Into<SourceRange<'a>>>(range: R) -> Self {
  468|    647|        let range = range.into();
  469|       |
  470|    647|        debug_assert_eq!(range.source_text().unwrap_or(""), "<<", "Expected '<<'");
  471|       |
  472|    647|        Self {
  473|    647|            kind: TokenKind::LessThanLessThan,
  474|    647|            range,
  475|    647|        }
  476|    647|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token29new_greater_than_greater_thanNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB7_:
  500|    526|    pub fn new_greater_than_greater_than<R: Into<SourceRange<'a>>>(range: R) -> Self {
  501|    526|        let range = range.into();
  502|       |
  503|    526|        debug_assert_eq!(range.source_text().unwrap_or(""), ">>", "Expected '>>'");
  504|       |
  505|    526|        Self {
  506|    526|            kind: TokenKind::GreaterThanGreaterThan,
  507|    526|            range,
  508|    526|        }
  509|    526|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token8new_bangNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  422|  8.04k|    pub fn new_bang<R: Into<SourceRange<'a>>>(range: R) -> Self {
  423|  8.04k|        let range = range.into();
  424|       |
  425|  8.04k|        debug_assert_eq!(range.source_text().unwrap_or(""), "!", "Expected '!'");
  426|       |
  427|  8.04k|        Self {
  428|  8.04k|            kind: TokenKind::Bang,
  429|  8.04k|            range,
  430|  8.04k|        }
  431|  8.04k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token8new_pipeNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  374|    984|    pub fn new_pipe<R: Into<SourceRange<'a>>>(range: R) -> Self {
  375|    984|        let range = range.into();
  376|       |
  377|    984|        debug_assert_eq!(range.source_text().unwrap_or(""), "|", "Expected '|'");
  378|       |
  379|    984|        Self {
  380|    984|            kind: TokenKind::Pipe,
  381|    984|            range,
  382|    984|        }
  383|    984|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token8new_plusNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  290|  2.45k|    pub fn new_plus<R: Into<SourceRange<'a>>>(range: R) -> Self {
  291|  2.45k|        let range = range.into();
  292|       |
  293|  2.45k|        debug_assert_eq!(range.source_text().unwrap_or(""), "+", "Expected '+'");
  294|       |
  295|  2.45k|        Self {
  296|  2.45k|            kind: TokenKind::Plus,
  297|  2.45k|            range,
  298|  2.45k|        }
  299|  2.45k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token8new_starNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  314|  1.11k|    pub fn new_star<R: Into<SourceRange<'a>>>(range: R) -> Self {
  315|  1.11k|        let range = range.into();
  316|       |
  317|  1.11k|        debug_assert_eq!(range.source_text().unwrap_or(""), "*", "Expected '*'");
  318|       |
  319|  1.11k|        Self {
  320|  1.11k|            kind: TokenKind::Star,
  321|  1.11k|            range,
  322|  1.11k|        }
  323|  1.11k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token9new_caretNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  362|    800|    pub fn new_caret<R: Into<SourceRange<'a>>>(range: R) -> Self {
  363|    800|        let range = range.into();
  364|       |
  365|    800|        debug_assert_eq!(range.source_text().unwrap_or(""), "^", "Expected '^'");
  366|       |
  367|    800|        Self {
  368|    800|            kind: TokenKind::Caret,
  369|    800|            range,
  370|    800|        }
  371|    800|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token9new_minusNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  266|  1.54k|    pub fn new_minus<R: Into<SourceRange<'a>>>(range: R) -> Self {
  267|  1.54k|        let range = range.into();
  268|       |
  269|  1.54k|        debug_assert_eq!(range.source_text().unwrap_or(""), "-", "Expected '-'");
  270|       |
  271|  1.54k|        Self {
  272|  1.54k|            kind: TokenKind::Minus,
  273|  1.54k|            range,
  274|  1.54k|        }
  275|  1.54k|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token9new_slashNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  242|    685|    pub fn new_slash<R: Into<SourceRange<'a>>>(range: R) -> Self {
  243|    685|        let range = range.into();
  244|       |
  245|    685|        debug_assert_eq!(range.source_text().unwrap_or(""), "/", "Expected '/'");
  246|       |
  247|    685|        Self {
  248|    685|            kind: TokenKind::Slash,
  249|    685|            range,
  250|    685|        }
  251|    685|    }
_RINvMs_NtCsdXdbFklkXPq_12rustcc_lexer5tokenNtB5_5Token9new_tildeNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB7_:
  254|  1.10k|    pub fn new_tilde<R: Into<SourceRange<'a>>>(range: R) -> Self {
  255|  1.10k|        let range = range.into();
  256|       |
  257|  1.10k|        debug_assert_eq!(range.source_text().unwrap_or(""), "~", "Expected '~'");
  258|       |
  259|  1.10k|        Self {
  260|  1.10k|            kind: TokenKind::Tilde,
  261|  1.10k|            range,
  262|  1.10k|        }
  263|  1.10k|    }

_RNvNtCslFLQ9nFMP2y_11rustcc_llvm8analysis15verify_function:
    5|  1.57k|pub fn verify_function(function: LLVMFunctionValue, action: LLVMVerifierFailureAction) -> bool {
    6|       |    // Safety: LLVMVerifyFunction is safe to call with valid parameters.
    7|  1.57k|    unsafe { LLVMVerifyFunction(function.as_raw(), action) == 0 }
    8|  1.57k|}

_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm11basic_blockNtB2_14LLVMBasicBlock10get_parent:
   26|    477|    pub fn get_parent(&self) -> Option<LLVMFunctionValue> {
   27|       |        // Safety: LLVMGetBasicBlockParent is safe to call with a valid
   28|       |        // LLVMBasicBlockRef.
   29|    477|        let func = unsafe { LLVMGetBasicBlockParent(self.as_raw()) };
   30|    477|        if func.is_null() {
   31|      0|            None
   32|       |        } else {
   33|    477|            Some(LLVMFunctionValue::from_raw(func))
   34|       |        }
   35|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm11basic_blockNtB2_14LLVMBasicBlock6as_raw:
   20|  8.73k|    pub(crate) fn as_raw(&self) -> LLVMBasicBlockRef {
   21|  8.73k|        assert!(!self.0.is_null(), "LLVMBasicBlock contains null pointer");
   22|  8.73k|        self.0
   23|  8.73k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm11basic_blockNtB2_14LLVMBasicBlock8from_raw:
   11|  3.96k|    pub(crate) fn from_raw(raw: LLVMBasicBlockRef) -> Self {
   12|  3.96k|        assert!(
   13|  3.96k|            !raw.is_null(),
   14|      0|            "Attempted to create LLVMBasicBlock from null pointer"
   15|       |        );
   16|  3.96k|        Self(raw)
   17|  3.96k|    }

_RINvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB3_11LLVMBuilder3phiReECshCskfrbP79Y_14rustcc_codegen:
  322|    477|    pub fn phi<'a, S: Into<&'a str>>(&self, typ: LLVMType, name: S) -> LLVMPhi {
  323|    477|        let name = to_cstring(name.into());
  324|       |        // Safety: LLVMBuildPhi is safe to call with valid parameters.
  325|    477|        LLVMPhi::from_raw(unsafe { LLVMBuildPhi(self.0, typ.as_raw(), name.as_ptr()) })
  326|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder10bitwise_or:
  176|    195|    pub fn bitwise_or(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  177|    195|        let name = to_cstring("or");
  178|       |        // Safety: LLVMBuildOr is safe to call with valid parameters.
  179|    195|        LLVMValue::from_raw(unsafe {
  180|    195|            LLVMBuildOr(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  181|       |        })
  182|    195|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder11bitwise_and:
  131|    203|    pub fn bitwise_and(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  132|    203|        let name = to_cstring("and");
  133|       |        // Safety: LLVMBuildAnd is safe to call with valid parameters.
  134|    203|        LLVMValue::from_raw(unsafe {
  135|    203|            LLVMBuildAnd(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  136|       |        })
  137|    203|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder11bitwise_xor:
  167|    194|    pub fn bitwise_xor(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  168|    194|        let name = to_cstring("xor");
  169|       |        // Safety: LLVMBuildXor is safe to call with valid parameters.
  170|    194|        LLVMValue::from_raw(unsafe {
  171|    194|            LLVMBuildXor(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  172|       |        })
  173|    194|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder11zero_extend:
  278|  4.95k|    pub fn zero_extend(&self, value: LLVMValue, to_type: LLVMType) -> LLVMValue {
  279|  4.95k|        let name = to_cstring("zext");
  280|       |        // Safety: LLVMBuildZExt is safe to call with valid parameters.
  281|  4.95k|        LLVMValue::from_raw(unsafe {
  282|  4.95k|            LLVMBuildZExt(self.0, value.as_raw(), to_type.as_raw(), name.as_ptr())
  283|       |        })
  284|  4.95k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder13integer_equal:
  208|  3.64k|    pub fn integer_equal(&self, lhs: LLVMValue, rhs: LLVMValue) -> LLVMValue {
  209|  3.64k|        let name = to_cstring("icmp_eq");
  210|  3.64k|        self.integer_compare(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, &name)
  211|  3.64k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder13signed_divide:
   93|    195|    pub fn signed_divide(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
   94|    195|        let name = to_cstring("sdiv");
   95|       |        // Safety: LLVMBuildSDiv is safe to call with valid parameters.
   96|    195|        LLVMValue::from_raw(unsafe {
   97|    195|            LLVMBuildSDiv(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
   98|       |        })
   99|    195|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder14new_in_context:
   25|      1|    pub fn new_in_context(context: &LLVMContext) -> Option<Self> {
   26|       |        // Safety: LLVMCreateBuilderInContext is safe to call with a valid
   27|       |        // LLVMContextRef.
   28|      1|        let builder = unsafe { LLVMCreateBuilderInContext(context.as_raw()) };
   29|       |
   30|      1|        if builder.is_null() {
   31|      0|            None
   32|       |        } else {
   33|      1|            Some(Self(builder))
   34|       |        }
   35|      1|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder15integer_compare:
  194|  5.91k|    fn integer_compare(
  195|  5.91k|        &self,
  196|  5.91k|        predicate: LLVMIntPredicate,
  197|  5.91k|        lhs: LLVMValue,
  198|  5.91k|        rhs: LLVMValue,
  199|  5.91k|        name: &CString,
  200|  5.91k|    ) -> LLVMValue {
  201|       |        // Safety: LLVMBuildICmp is safe to call with valid parameters.
  202|  5.91k|        LLVMValue::from_raw(unsafe {
  203|  5.91k|            LLVMBuildICmp(self.0, predicate, lhs.as_raw(), rhs.as_raw(), name.as_ptr())
  204|       |        })
  205|  5.91k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder15position_at_end:
   37|  3.48k|    pub fn position_at_end(&self, basic_block: LLVMBasicBlock) {
   38|       |        // Safety: LLVMPositionBuilderAtEnd is safe to call with valid parameters.
   39|  3.48k|        unsafe { LLVMPositionBuilderAtEnd(self.0, basic_block.as_raw()) };
   40|  3.48k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder16get_insert_block:
   43|    477|    pub fn get_insert_block(&self) -> Option<LLVMBasicBlock> {
   44|       |        // Safety: LLVMGetInsertBlock is safe to call with a valid LLVMBuilderRef.
   45|    477|        let block = unsafe { LLVMGetInsertBlock(self.0) };
   46|    477|        if block.is_null() {
   47|      0|            None
   48|       |        } else {
   49|    477|            Some(LLVMBasicBlock::from_raw(block))
   50|       |        }
   51|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder16signed_remainder:
  111|    214|    pub fn signed_remainder(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  112|    214|        let name = to_cstring("srem");
  113|       |        // Safety: LLVMBuildSRem is safe to call with valid parameters.
  114|    214|        LLVMValue::from_raw(unsafe {
  115|    214|            LLVMBuildSRem(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  116|       |        })
  117|    214|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder17integer_not_equal:
  214|  1.14k|    pub fn integer_not_equal(&self, lhs: LLVMValue, rhs: LLVMValue) -> LLVMValue {
  215|  1.14k|        let name = to_cstring("icmp_ne");
  216|  1.14k|        self.integer_compare(LLVMIntPredicate::LLVMIntNE, lhs, rhs, &name)
  217|  1.14k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder18bitwise_complement:
  185|    317|    pub fn bitwise_complement(&self, value: LLVMValue) -> LLVMValue {
  186|    317|        let name = to_cstring("not");
  187|       |        // Safety: LLVMBuildNot is safe to call with valid parameters.
  188|    317|        LLVMValue::from_raw(unsafe { LLVMBuildNot(self.0, value.as_raw(), name.as_ptr()) })
  189|    317|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder18bitwise_left_shift:
  140|    194|    pub fn bitwise_left_shift(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  141|    194|        let name = to_cstring("shl");
  142|       |        // Safety: LLVMBuildShl is safe to call with valid parameters.
  143|    194|        LLVMValue::from_raw(unsafe {
  144|    194|            LLVMBuildShl(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  145|       |        })
  146|    194|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder18conditional_branch:
  298|    954|    pub fn conditional_branch(
  299|    954|        &self,
  300|    954|        condition: LLVMValue,
  301|    954|        then_bb: LLVMBasicBlock,
  302|    954|        else_bb: LLVMBasicBlock,
  303|    954|    ) -> LLVMValue {
  304|       |        // Safety: LLVMBuildCondBr is safe to call with valid parameters.
  305|    954|        LLVMValue::from_raw(unsafe {
  306|    954|            LLVMBuildCondBr(
  307|    954|                self.0,
  308|    954|                condition.as_raw(),
  309|    954|                then_bb.as_raw(),
  310|    954|                else_bb.as_raw(),
  311|       |            )
  312|       |        })
  313|    954|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder20unconditional_branch:
  316|    954|    pub fn unconditional_branch(&self, target_bb: LLVMBasicBlock) -> LLVMValue {
  317|       |        // Safety: LLVMBuildBr is safe to call with valid parameters.
  318|    954|        LLVMValue::from_raw(unsafe { LLVMBuildBr(self.0, target_bb.as_raw()) })
  319|    954|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder24integer_signed_less_than:
  264|    203|    pub fn integer_signed_less_than(&self, lhs: LLVMValue, rhs: LLVMValue) -> LLVMValue {
  265|    203|        let name = to_cstring("icmp_slt");
  266|    203|        self.integer_compare(LLVMIntPredicate::LLVMIntSLT, lhs, rhs, &name)
  267|    203|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder27integer_signed_greater_than:
  248|    505|    pub fn integer_signed_greater_than(&self, lhs: LLVMValue, rhs: LLVMValue) -> LLVMValue {
  249|    505|        let name = to_cstring("icmp_sgt");
  250|    505|        self.integer_compare(LLVMIntPredicate::LLVMIntSGT, lhs, rhs, &name)
  251|    505|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder30bitwise_arithmetic_right_shift:
  149|    200|    pub fn bitwise_arithmetic_right_shift(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
  150|    200|        let name = to_cstring("ashr");
  151|       |        // Safety: LLVMBuildAShr is safe to call with valid parameters.
  152|    200|        LLVMValue::from_raw(unsafe {
  153|    200|            LLVMBuildAShr(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
  154|       |        })
  155|    200|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder33integer_signed_less_than_or_equal:
  270|    194|    pub fn integer_signed_less_than_or_equal(&self, lhs: LLVMValue, rhs: LLVMValue) -> LLVMValue {
  271|    194|        let name = to_cstring("icmp_sle");
  272|    194|        self.integer_compare(LLVMIntPredicate::LLVMIntSLE, lhs, rhs, &name)
  273|    194|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder36integer_signed_greater_than_or_equal:
  254|    218|    pub fn integer_signed_greater_than_or_equal(
  255|    218|        &self,
  256|    218|        lhs: LLVMValue,
  257|    218|        rhs: LLVMValue,
  258|    218|    ) -> LLVMValue {
  259|    218|        let name = to_cstring("icmp_sge");
  260|    218|        self.integer_compare(LLVMIntPredicate::LLVMIntSGE, lhs, rhs, &name)
  261|    218|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder3add:
   66|    198|    pub fn add(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
   67|    198|        let name = to_cstring("add");
   68|       |        // Safety: LLVMBuildAdd is safe to call with valid parameters.
   69|    198|        LLVMValue::from_raw(unsafe {
   70|    198|            LLVMBuildAdd(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
   71|       |        })
   72|    198|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder3ret:
   53|  1.57k|    pub fn ret(&self, value: LLVMValue) {
   54|       |        // Safety: LLVMBuildRet is safe to call with valid parameters.
   55|  1.57k|        unsafe { LLVMBuildRet(self.0, value.as_raw()) };
   56|  1.57k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder6negate:
   59|    261|    pub fn negate(&self, value: LLVMValue) -> LLVMValue {
   60|    261|        let name = to_cstring("neg");
   61|       |        // Safety: LLVMBuildNeg is safe to call with valid parameters.
   62|    261|        LLVMValue::from_raw(unsafe { LLVMBuildNeg(self.0, value.as_raw(), name.as_ptr()) })
   63|    261|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder8multiply:
   84|    196|    pub fn multiply(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
   85|    196|        let name = to_cstring("mul");
   86|       |        // Safety: LLVMBuildMul is safe to call with valid parameters.
   87|    196|        LLVMValue::from_raw(unsafe {
   88|    196|            LLVMBuildMul(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
   89|       |        })
   90|    196|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB2_11LLVMBuilder8subtract:
   75|    197|    pub fn subtract(&self, left: LLVMValue, right: LLVMValue) -> LLVMValue {
   76|    197|        let name = to_cstring("sub");
   77|       |        // Safety: LLVMBuildSub is safe to call with valid parameters.
   78|    197|        LLVMValue::from_raw(unsafe {
   79|    197|            LLVMBuildSub(self.0, left.as_raw(), right.as_raw(), name.as_ptr())
   80|       |        })
   81|    197|    }
_RNvXs_NtCslFLQ9nFMP2y_11rustcc_llvm7builderNtB4_11LLVMBuilderNtNtNtCs6SNw0SRvItZ_4core3ops4drop4Drop4drop:
  330|      1|    fn drop(&mut self) {
  331|       |        // Safety: LLVMDisposeBuilder is safe to call with a valid LLVMBuilderRef.
  332|      1|        unsafe { LLVMDisposeBuilder(self.0) };
  333|      1|    }

_RINvMNtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB3_11LLVMContext18create_basic_blockReECshCskfrbP79Y_14rustcc_codegen:
   89|  1.90k|    pub fn create_basic_block<'a, S: Into<&'a str>>(&self, name: S) -> LLVMBasicBlock {
   90|  1.90k|        let name = to_cstring(name.into());
   91|       |        // Safety: LLVMCreateBasicBlockInContext is safe to call with valid parameters.
   92|  1.90k|        LLVMBasicBlock::from_raw(unsafe { LLVMCreateBasicBlockInContext(self.0, name.as_ptr()) })
   93|  1.90k|    }
_RINvMNtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB3_11LLVMContext31create_basic_block_for_functionReECshCskfrbP79Y_14rustcc_codegen:
   77|  1.57k|    pub fn create_basic_block_for_function<'a, S: Into<&'a str>>(
   78|  1.57k|        &self,
   79|  1.57k|        function: &LLVMFunctionValue,
   80|  1.57k|        name: S,
   81|  1.57k|    ) -> LLVMBasicBlock {
   82|  1.57k|        let name = to_cstring(name.into());
   83|       |        // Safety: LLVMAppendBasicBlockInContext is safe to call with valid parameters.
   84|  1.57k|        LLVMBasicBlock::from_raw(unsafe {
   85|  1.57k|            LLVMAppendBasicBlockInContext(self.0, function.as_raw(), name.as_ptr())
   86|       |        })
   87|  1.57k|    }
_RNvXs_NtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB4_11LLVMContextNtNtNtCs6SNw0SRvItZ_4core3ops4drop4Drop4drop:
   97|      1|    fn drop(&mut self) {
   98|       |        // Safety: LLVMContextDispose is safe to call with a valid LLVMContextRef.
   99|      1|        unsafe { LLVMContextDispose(self.0) };
  100|      1|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB2_11LLVMContext10int32_type:
   55|  17.4k|    pub fn int32_type(&self) -> LLVMType {
   56|       |        // Safety: LLVMInt32TypeInContext is safe to call with a valid LLVMContextRef.
   57|  17.4k|        LLVMType::from_raw(unsafe { LLVMInt32TypeInContext(self.0) })
   58|  17.4k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB2_11LLVMContext3new:
   20|      1|    pub fn new() -> Option<Self> {
   21|       |        // Safety: LLVMContextCreate is safe to call and returns a valid LLVMContextRef
   22|       |        // or null.
   23|      1|        let context = unsafe { LLVMContextCreate() };
   24|      1|        if context.is_null() {
   25|      0|            None
   26|       |        } else {
   27|      1|            Some(Self(context))
   28|       |        }
   29|      1|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm7contextNtB2_11LLVMContext6as_raw:
   31|  1.31k|    pub(crate) fn as_raw(&self) -> LLVMContextRef {
   32|  1.31k|        assert!(!self.0.is_null(), "LLVMContext contains null pointer");
   33|  1.31k|        self.0
   34|  1.31k|    }

_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm8functionNtB2_16LLVMFunctionType6as_raw:
   21|  1.57k|    pub(crate) fn as_raw(&self) -> LLVMTypeRef {
   22|  1.57k|        self.0.as_raw()
   23|  1.57k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm8functionNtB2_16LLVMFunctionType8from_raw:
   16|  1.57k|    pub(crate) fn from_raw(raw: LLVMTypeRef) -> Self {
   17|  1.57k|        Self(LLVMType::from_raw(raw))
   18|  1.57k|    }
_RNvMs_NtCslFLQ9nFMP2y_11rustcc_llvm8functionNtB4_17LLVMFunctionValue27append_existing_basic_block:
   46|  1.90k|    pub fn append_existing_basic_block(&self, basic_block: LLVMBasicBlock) {
   47|       |        // Safety: LLVMAppendExistingBasicBlock is safe to call with valid parameters.
   48|  1.90k|        unsafe { LLVMAppendExistingBasicBlock(self.as_raw(), basic_block.as_raw()) };
   49|  1.90k|    }
_RNvMs_NtCslFLQ9nFMP2y_11rustcc_llvm8functionNtB4_17LLVMFunctionValue6as_raw:
   42|  5.06k|    pub(crate) fn as_raw(&self) -> LLVMValueRef {
   43|  5.06k|        self.0.as_raw()
   44|  5.06k|    }
_RNvMs_NtCslFLQ9nFMP2y_11rustcc_llvm8functionNtB4_17LLVMFunctionValue8from_raw:
   37|  2.05k|    pub(crate) fn from_raw(raw: LLVMValueRef) -> Self {
   38|  2.05k|        Self(LLVMValue::from_raw(raw))
   39|  2.05k|    }
_RNvNtCslFLQ9nFMP2y_11rustcc_llvm8function13function_type:
   58|  1.57k|pub fn function_type(return_type: LLVMType) -> LLVMFunctionType {
   59|       |    // SAFETY: The caller must ensure that `return_type` is a valid LLVM type.
   60|  1.57k|    LLVMFunctionType::from_raw(unsafe {
   61|  1.57k|        crate::ffi::LLVMFunctionType(return_type.as_raw(), ptr::null_mut(), 0, 0)
   62|       |    })
   63|  1.57k|}

_RINvCslFLQ9nFMP2y_11rustcc_llvm10to_cstringReEB2_:
   24|  20.2k|fn to_cstring<'a, S: Into<&'a str>>(string: S) -> std::ffi::CString {
   25|  20.2k|    std::ffi::CString::new(string.into()).expect("Invalid string")
   26|  20.2k|}

_RINvMNtCslFLQ9nFMP2y_11rustcc_llvm6moduleNtB3_10LLVMModule12add_functionReECshCskfrbP79Y_14rustcc_codegen:
   29|  1.57k|    pub fn add_function<'a, S: Into<&'a str>>(
   30|  1.57k|        &self,
   31|  1.57k|        name: S,
   32|  1.57k|        function_type: LLVMFunctionType,
   33|  1.57k|    ) -> LLVMFunctionValue {
   34|  1.57k|        let name = to_cstring(name.into());
   35|       |        // Safety: LLVMAddFunction is safe to call with valid parameters.
   36|  1.57k|        LLVMFunctionValue::from_raw(unsafe {
   37|  1.57k|            LLVMAddFunction(self.0, name.as_ptr(), function_type.as_raw())
   38|       |        })
   39|  1.57k|    }
_RINvMNtCslFLQ9nFMP2y_11rustcc_llvm6moduleNtB3_10LLVMModule14new_in_contextReECshCskfrbP79Y_14rustcc_codegen:
   16|  1.31k|    pub fn new_in_context<'a, S: Into<&'a str>>(name: S, context: &LLVMContext) -> Option<Self> {
   17|  1.31k|        let name = to_cstring(name.into());
   18|       |        // Safety: LLVMModuleCreateWithNameInContext is safe to call with valid
   19|       |        // parameters.
   20|  1.31k|        let module = unsafe { LLVMModuleCreateWithNameInContext(name.as_ptr(), context.as_raw()) };
   21|  1.31k|        if module.is_null() {
   22|      0|            None
   23|       |        } else {
   24|  1.31k|            Some(Self(module))
   25|       |        }
   26|  1.31k|    }
_RNvXs_NtCslFLQ9nFMP2y_11rustcc_llvm6moduleNtB4_10LLVMModuleNtNtNtCs6SNw0SRvItZ_4core3ops4drop4Drop4drop:
   48|  1.31k|    fn drop(&mut self) {
   49|       |        // Safety: LLVMDisposeModule is safe to call with a valid LLVMModuleRef.
   50|  1.31k|        unsafe { LLVMDisposeModule(self.0) };
   51|  1.31k|    }

_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3phiNtB2_7LLVMPhi12add_incoming:
   23|    477|    pub fn add_incoming(&self, values: &[LLVMValue], blocks: &[LLVMBasicBlock]) {
   24|    477|        assert!(
   25|    477|            values.len() == blocks.len(),
   26|      0|            "Values and blocks must have the same length"
   27|       |        );
   28|       |        #[expect(clippy::cast_possible_truncation)]
   29|    477|        let count = values.len() as u32;
   30|       |
   31|    477|        assert!(count > 0, "Cannot add zero incoming values to a PHI node");
   32|       |
   33|    477|        let values_ptr = values.as_ptr() as *mut LLVMValueRef;
   34|    477|        let blocks_ptr = blocks.as_ptr() as *mut LLVMBasicBlockRef;
   35|       |
   36|       |        // Safety: LLVMAddIncoming is safe to call with valid parameters.
   37|    477|        unsafe { LLVMAddIncoming(self.as_raw(), values_ptr, blocks_ptr, count) };
   38|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3phiNtB2_7LLVMPhi5value:
   41|    477|    pub const fn value(&self) -> LLVMValue {
   42|    477|        self.0
   43|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3phiNtB2_7LLVMPhi6as_raw:
   18|    477|    pub(crate) fn as_raw(&self) -> LLVMValueRef {
   19|    477|        self.0.as_raw()
   20|    477|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3phiNtB2_7LLVMPhi8from_raw:
   13|    477|    pub(crate) fn from_raw(raw: LLVMValueRef) -> Self {
   14|    477|        Self(LLVMValue::from_raw(raw))
   15|    477|    }

_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3typNtB2_8LLVMType16constant_integer:
   25|  10.4k|    pub fn constant_integer(&self, value: u64, sign_extend: bool) -> LLVMValue {
   26|       |        // SAFETY: LLVMConstInt creates a constant integer value of the specified type.
   27|       |        // The caller must ensure that `typ` is a valid integer type.
   28|  10.4k|        LLVMValue::from_raw(unsafe {
   29|  10.4k|            LLVMConstInt(self.as_raw(), value, LLVMBool::from(sign_extend))
   30|       |        })
   31|  10.4k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3typNtB2_8LLVMType6as_raw:
   19|  19.0k|    pub(crate) fn as_raw(&self) -> LLVMTypeRef {
   20|  19.0k|        assert!(!self.0.is_null(), "LLVMType contains null pointer");
   21|  19.0k|        self.0
   22|  19.0k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm3typNtB2_8LLVMType8from_raw:
   11|  19.0k|    pub(crate) fn from_raw(raw: LLVMTypeRef) -> Self {
   12|  19.0k|        assert!(
   13|  19.0k|            !raw.is_null(),
   14|      0|            "Attempted to create LLVMType from null pointer"
   15|       |        );
   16|  19.0k|        Self(raw)
   17|  19.0k|    }

_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm5valueNtB2_9LLVMValue6as_raw:
   16|  29.3k|    pub(crate) fn as_raw(&self) -> LLVMValueRef {
   17|  29.3k|        assert!(!self.0.is_null(), "LLVMValue contains null pointer");
   18|  29.3k|        self.0
   19|  29.3k|    }
_RNvMNtCslFLQ9nFMP2y_11rustcc_llvm5valueNtB2_9LLVMValue8from_raw:
    8|  28.2k|    pub(crate) fn from_raw(raw: LLVMValueRef) -> Self {
    9|  28.2k|        assert!(
   10|  28.2k|            !raw.is_null(),
   11|      0|            "Attempted to create LLVMValue from null pointer"
   12|       |        );
   13|  28.2k|        Self(raw)
   14|  28.2k|    }

_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser11is_finished:
   46|  22.8k|    fn is_finished(&self) -> bool {
   47|  22.8k|        *self.index.borrow() >= self.tokens.len()
   48|  22.8k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser12consume_next:
   64|  39.4k|    fn consume_next(&self) -> Option<&Token<'a>> {
   65|  39.4k|        let token = self.peek_next();
   66|  39.4k|        self.consume();
   67|  39.4k|        token
   68|  39.4k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser12parse_factor:
  259|  69.5k|    fn parse_factor(&'_ self) -> Option<Expression<'_>> {
  260|  69.5k|        let Some(token) = self.peek_next() else {
  261|    198|            self.diagnostic(
  262|    198|                DiagnosticId::ExpectedExpression,
  263|    198|                self.current_token_source_range(),
  264|       |                "expected expression but reached end of file",
  265|       |            );
  266|    198|            return None;
  267|       |        };
  268|       |
  269|       |        #[expect(clippy::wildcard_enum_match_arm)]
  270|  51.4k|        match &token.kind {
  271|  10.1k|            TokenKind::IntegerLiteral(_) => self.parse_integer_literal(),
  272|  59.1k|            x if x.is_unary_operator() => self.parse_unary_expression(),
  273|  51.2k|            TokenKind::LeftParenthesis => self.parse_parenthesis_expression(),
  274|       |
  275|       |            _ => {
  276|    239|                self.diagnostic(
  277|    239|                    DiagnosticId::ExpectedExpression,
  278|    239|                    token.range,
  279|       |                    "expected expression",
  280|       |                );
  281|    239|                None
  282|       |            }
  283|       |        }
  284|  69.5k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser15parse_statement:
  179|  21.5k|    fn parse_statement(&'_ self) -> Option<Statement<'_>> {
  180|       |        // TODO: Statement can be all sorts of things, for now we only allow the
  181|       |        // return statement
  182|  21.5k|        self.parse_return_statement()
  183|  21.5k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser16parse_expression:
  227|  61.8k|    fn parse_expression(&'_ self, minimum_precedence: u8) -> Option<Expression<'_>> {
  228|  61.8k|        let mut left = self.parse_factor()?;
  229|       |
  230|  19.8k|        while let Some(token) = self.peek_next() {
  231|  18.7k|            if let Some(operator) = token.binary_operator()
  232|  13.5k|                && operator.precedence() >= minimum_precedence
  233|       |            {
  234|  7.78k|                self.consume();
  235|       |
  236|  7.78k|                let right = self.parse_expression(operator.precedence() + 1)?;
  237|       |
  238|  6.67k|                let range = SourceRange {
  239|  6.67k|                    begin: left.range.begin,
  240|  6.67k|                    end: right.range.end,
  241|  6.67k|                };
  242|       |
  243|  6.67k|                left = Expression {
  244|  6.67k|                    kind: ExpressionKind::BinaryOperation {
  245|  6.67k|                        operator,
  246|  6.67k|                        left: Box::new(left),
  247|  6.67k|                        right: Box::new(right),
  248|  6.67k|                    },
  249|  6.67k|                    range,
  250|  6.67k|                };
  251|       |            } else {
  252|  10.9k|                break;
  253|       |            }
  254|       |        }
  255|       |
  256|  12.0k|        Some(left)
  257|  61.8k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser21parse_integer_literal:
  286|  10.1k|    fn parse_integer_literal(&'_ self) -> Option<Expression<'_>> {
  287|  10.1k|        let token = self.consume_next()?;
  288|       |
  289|  10.1k|        let TokenKind::IntegerLiteral(value) = token.kind else {
  290|      0|            self.diagnostic(
  291|      0|                DiagnosticId::ExpectedIntegerLiteral,
  292|      0|                token.range,
  293|       |                "expected integer literal",
  294|       |            );
  295|      0|            return None;
  296|       |        };
  297|       |
  298|  10.1k|        Some(Expression {
  299|  10.1k|            kind: ExpressionKind::IntegerLiteral(value),
  300|  10.1k|            range: token.range,
  301|  10.1k|        })
  302|  10.1k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser22parse_return_statement:
  185|  21.5k|    fn parse_return_statement(&'_ self) -> Option<Statement<'_>> {
  186|       |        // Require the 'return' keyword
  187|  21.5k|        let Some(return_token) = self.expect(&TokenKind::KeywordReturn) else {
  188|  18.6k|            self.diagnostic(
  189|  18.6k|                DiagnosticId::ExpectedReturnKeyword,
  190|  18.6k|                self.current_token_source_range(),
  191|       |                "expected 'return' keyword",
  192|       |            );
  193|  18.6k|            return None;
  194|       |        };
  195|       |
  196|       |        // Parse the expression
  197|  2.84k|        let Some(expression) = self.parse_expression(0) else {
  198|    437|            self.diagnostic(
  199|    437|                DiagnosticId::ExpectedExpression,
  200|    437|                return_token.range.end,
  201|       |                "expected expression instead reached end of file",
  202|       |            );
  203|    437|            return None;
  204|       |        };
  205|       |
  206|       |        // Require a semicolon
  207|  2.40k|        let Some(semicolon_token) = self.expect(&TokenKind::Semicolon) else {
  208|    830|            self.diagnostic(
  209|    830|                DiagnosticId::ExpectedSemicolon,
  210|    830|                self.current_token_source_range(),
  211|       |                "expected ';'",
  212|       |            );
  213|    830|            return None;
  214|       |        };
  215|       |
  216|  1.57k|        Some(Statement::new_return(
  217|  1.57k|            expression,
  218|  1.57k|            SourceRange {
  219|  1.57k|                begin: return_token.range.begin,
  220|  1.57k|                end: semicolon_token.range.end,
  221|  1.57k|            },
  222|  1.57k|        ))
  223|  21.5k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser22parse_unary_expression:
  304|  7.70k|    fn parse_unary_expression(&'_ self) -> Option<Expression<'_>> {
  305|  7.70k|        let operator_token = self.consume_next()?;
  306|       |
  307|  7.70k|        let operator = operator_token.unary_operator()?;
  308|       |
  309|  7.70k|        let expression = self.parse_factor()?;
  310|  7.13k|        let range = SourceRange {
  311|  7.13k|            begin: operator_token.range.begin,
  312|  7.13k|            end: expression.range.end,
  313|  7.13k|        };
  314|       |
  315|  7.13k|        Some(Expression {
  316|  7.13k|            kind: ExpressionKind::UnaryOperation {
  317|  7.13k|                operator,
  318|  7.13k|                expression: Box::new(expression),
  319|  7.13k|            },
  320|  7.13k|            range,
  321|  7.13k|        })
  322|  7.70k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser25parse_function_definition:
   93|  21.5k|    fn parse_function_definition(&'_ self) -> Option<FunctionDefinition<'_>> {
   94|       |        // First parse the function return type.
   95|       |        // TODO: For now we only support 'int' return type.
   96|  21.5k|        if self.expect(&TokenKind::KeywordInt).is_none() {
   97|  21.3k|            self.diagnostic(
   98|  21.3k|                DiagnosticId::ExpectedFunctionReturnType,
   99|  21.3k|                self.current_token_source_range(),
  100|  21.3k|                "expected 'int' keyword",
  101|  21.3k|            );
  102|  21.3k|        }
  103|       |
  104|       |        // Parse the function name
  105|  21.5k|        let Some(name_token) = self.consume_next() else {
  106|      9|            self.diagnostic(
  107|      9|                DiagnosticId::ExpectedFunctionName,
  108|      9|                self.current_token_source_range(),
  109|       |                "expected function name but reached end of file",
  110|       |            );
  111|      9|            return None;
  112|       |        };
  113|       |
  114|  21.5k|        let name = name_token
  115|  21.5k|            .range
  116|  21.5k|            .source_text()
  117|  21.5k|            .map(std::string::ToString::to_string)
  118|  21.5k|            .unwrap_or_default();
  119|  21.5k|        if !name_token.is_identifier() || name.is_empty() {
  120|  18.0k|            self.diagnostic(
  121|  18.0k|                DiagnosticId::ExpectedFunctionName,
  122|  18.0k|                self.current_token_source_range(),
  123|  18.0k|                "expected function name",
  124|  18.0k|            );
  125|  18.0k|        }
  126|       |
  127|       |        // Require an open parenthesis
  128|  21.5k|        if self.expect(&TokenKind::LeftParenthesis).is_none() {
  129|  20.5k|            self.diagnostic(
  130|  20.5k|                DiagnosticId::ExpectedLeftParenthesis,
  131|  20.5k|                self.current_token_source_range(),
  132|  20.5k|                "expected '('",
  133|  20.5k|            );
  134|  20.5k|        }
  135|       |
  136|       |        // TODO: Now we would parse the function parameters, but for now just
  137|       |        // skip them We currently require a void parameter
  138|  21.5k|        if self.expect(&TokenKind::KeywordVoid).is_none() {
  139|  21.3k|            self.diagnostic(
  140|  21.3k|                DiagnosticId::ExpectedVoidInParameterList,
  141|  21.3k|                self.current_token_source_range(),
  142|  21.3k|                "expected 'void' keyword for parameter list",
  143|  21.3k|            );
  144|  21.3k|        }
  145|       |
  146|       |        // Require a closing parenthesis
  147|  21.5k|        if self.expect(&TokenKind::RightParenthesis).is_none() {
  148|  21.0k|            self.diagnostic(
  149|  21.0k|                DiagnosticId::ExpectedRightParenthesis,
  150|  21.0k|                self.current_token_source_range(),
  151|  21.0k|                "expected ')'",
  152|  21.0k|            );
  153|  21.0k|        }
  154|       |
  155|       |        // Require an open brace
  156|  21.5k|        if self.expect(&TokenKind::LeftBrace).is_none() {
  157|  21.0k|            self.diagnostic(
  158|  21.0k|                DiagnosticId::ExpectedLeftBrace,
  159|  21.0k|                self.current_token_source_range(),
  160|  21.0k|                "expected '{'",
  161|  21.0k|            );
  162|  21.0k|        }
  163|       |
  164|       |        // Parse the function body
  165|  21.5k|        let body = self.parse_statement()?;
  166|       |
  167|       |        // Require a closing brace
  168|  1.57k|        if self.expect(&TokenKind::RightBrace).is_none() {
  169|  1.38k|            self.diagnostic(
  170|  1.38k|                DiagnosticId::ExpectedRightBrace,
  171|  1.38k|                self.current_token_source_range(),
  172|  1.38k|                "expected '}'",
  173|  1.38k|            );
  174|  1.38k|        }
  175|       |
  176|  1.57k|        Some(FunctionDefinition { name, body })
  177|  21.5k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser26current_token_source_range:
   50|   146k|    fn current_token_source_range(&self) -> SourceRange<'a> {
   51|   146k|        self.peek_next()
   52|   146k|            .map(|token| token.range)
   53|   146k|            .unwrap_or_default()
   54|   146k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser28parse_parenthesis_expression:
  324|  51.2k|    fn parse_parenthesis_expression(&'_ self) -> Option<Expression<'_>> {
  325|       |        // Opening parenthesis
  326|  51.2k|        let opnening_parenthesis_token = self.expect(&TokenKind::LeftParenthesis)?;
  327|       |
  328|  51.2k|        let expression = self.parse_expression(0)?;
  329|       |
  330|       |        // Closing parenthesis
  331|  2.96k|        let closing_paren_token = self.expect(&TokenKind::RightParenthesis);
  332|  2.96k|        if closing_paren_token.is_none() {
  333|  2.46k|            self.diagnostic(
  334|  2.46k|                DiagnosticId::MissingClosingParenthesis,
  335|  2.46k|                self.current_token_source_range(),
  336|  2.46k|                "missing closing right parenthesis ')'",
  337|  2.46k|            );
  338|  2.46k|        }
  339|       |
  340|  2.96k|        let range = SourceRange {
  341|  2.96k|            begin: opnening_parenthesis_token.range.begin,
  342|  2.96k|            end: closing_paren_token.map_or(expression.range.end, |token| token.range.end),
  343|       |        };
  344|       |
  345|  2.96k|        Some(Expression {
  346|  2.96k|            kind: ExpressionKind::Parenthesis(Box::new(expression)),
  347|  2.96k|            range,
  348|  2.96k|        })
  349|  51.2k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser3new:
   27|  1.31k|    pub fn new(diagnostic_engine: Rc<RefCell<DiagnosticEngine>>, tokens: TokenList<'a>) -> Self {
   28|  1.31k|        Parser {
   29|  1.31k|            diagnostic_engine,
   30|  1.31k|            tokens,
   31|  1.31k|            index: RefCell::from(0),
   32|  1.31k|        }
   33|  1.31k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser5parse:
   81|  1.31k|    pub fn parse(&'_ mut self) -> TranslationUnit<'_> {
   82|  1.31k|        let mut translation_unit = TranslationUnit::new();
   83|       |
   84|  22.8k|        while !self.is_finished() {
   85|  21.5k|            if let Some(function_definition) = self.parse_function_definition() {
   86|  1.57k|                translation_unit.function.push(function_definition);
   87|  19.9k|            }
   88|       |        }
   89|       |
   90|  1.31k|        translation_unit
   91|  1.31k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser6expect:
   70|   187k|    fn expect(&self, token_kind: &TokenKind) -> Option<&Token<'a>> {
   71|   187k|        if let Some(token) = self.peek_next()
   72|   183k|            && token.kind == *token_kind
   73|       |        {
   74|  58.7k|            self.consume();
   75|  58.7k|            return Some(token);
   76|   128k|        }
   77|       |
   78|   128k|        None
   79|   187k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser7consume:
   60|   105k|    fn consume(&self) {
   61|   105k|        *self.index.borrow_mut() += 1;
   62|   105k|    }
_RNvMCs883XhAbT7Nq_13rustcc_parserNtB2_6Parser9peek_next:
   56|   463k|    fn peek_next(&self) -> Option<&Token<'a>> {
   57|   463k|        self.tokens.get(*self.index.borrow())
   58|   463k|    }
_RINvMCs883XhAbT7Nq_13rustcc_parserNtB3_6Parser10diagnosticReNtNtCsgxSeqfT5AE1_13rustcc_source12source_range11SourceRangeEB3_:
   35|   147k|    fn diagnostic<S: Into<String>, R: Into<SourceRange<'a>>>(
   36|   147k|        &'a self,
   37|   147k|        id: DiagnosticId,
   38|   147k|        source_range: R,
   39|   147k|        message: S,
   40|   147k|    ) -> DiagnosticBuilder<'a> {
   41|   147k|        let diagnostic = Diagnostic::new(id, source_range, message);
   42|       |
   43|   147k|        DiagnosticBuilder::new(self.diagnostic_engine.clone(), diagnostic)
   44|   147k|    }
_RINvMCs883XhAbT7Nq_13rustcc_parserNtB3_6Parser10diagnosticReNtNtCsgxSeqfT5AE1_13rustcc_source15source_location14SourceLocationEB3_:
   35|    437|    fn diagnostic<S: Into<String>, R: Into<SourceRange<'a>>>(
   36|    437|        &'a self,
   37|    437|        id: DiagnosticId,
   38|    437|        source_range: R,
   39|    437|        message: S,
   40|    437|    ) -> DiagnosticBuilder<'a> {
   41|    437|        let diagnostic = Diagnostic::new(id, source_range, message);
   42|       |
   43|    437|        DiagnosticBuilder::new(self.diagnostic_engine.clone(), diagnostic)
   44|    437|    }

_RINvMNtCsgxSeqfT5AE1_13rustcc_source11source_fileNtB3_10SourceFile3newReB16_ECs8IHyuhOPnlA_12fuzz_compile:
   21|  1.31k|    pub fn new<P: Into<String>, C: Into<String>>(path: P, content: C) -> Self {
   22|  1.31k|        let path = path.into();
   23|       |
   24|       |        // Assert that path is a valid path
   25|  1.31k|        assert!(!path.contains('\0'), "Path contains null byte");
   26|  1.31k|        assert!(!path.contains('\n'), "Path contains newline");
   27|  1.31k|        assert!(!path.contains(".."), "Path contains '..'");
   28|  1.31k|        assert!(!path.contains("//"), "Path contains '//'");
   29|  1.31k|        assert!(!path.contains("\\\\"), "Path contains '\\\\'");
   30|  1.31k|        assert!(!path.contains("/*"), "Path contains '/*'");
   31|  1.31k|        assert!(!path.contains("*/"), "Path contains '*/'");
   32|       |
   33|  1.31k|        Self {
   34|  1.31k|            path,
   35|  1.31k|            content: content.into(),
   36|  1.31k|        }
   37|  1.31k|    }

_RNvMNtCsgxSeqfT5AE1_13rustcc_source15source_locationNtB2_14SourceLocation3new:
   52|   160k|    pub fn new(source_file: &'a SourceFile, index: usize, line: u32, column: u32) -> Self {
   53|   160k|        assert!(
   54|   160k|            line > 0,
   55|      0|            "Line must be greater than 0.\nSource file: '{}'",
   56|       |            source_file.path
   57|       |        );
   58|   160k|        assert!(
   59|   160k|            column > 0,
   60|      0|            "Column must be greater than 0\nSource file: '{}'",
   61|       |            source_file.path
   62|       |        );
   63|       |
   64|   160k|        let file_lines = source_file.content.lines().count();
   65|   160k|        let line_length = source_file
   66|   160k|            .content
   67|   160k|            .lines()
   68|   160k|            .nth((line - 1) as usize)
   69|   160k|            .map(|line| line.chars().count());
   70|   160k|        let file_chars = source_file.content.len();
   71|       |
   72|   160k|        assert!(
   73|   160k|            file_lines >= line as usize,
   74|      0|            "Line number exceeds the number of lines in the source file.\nExpected at most \
   75|      0|             {file_lines}, found {line}\nSource file: '{}'",
   76|       |            source_file.path
   77|       |        );
   78|   160k|        if let Some(line_length) = line_length {
   79|   160k|            assert!(
   80|   160k|                line_length >= column as usize,
   81|      0|                "Column number exceeds the number of characters in the line.\nExpected at most \
   82|      0|                 {line_length}, found {column}.\nSource file: '{}'\nLine: {line}",
   83|       |                source_file.path
   84|       |            );
   85|      0|        }
   86|   160k|        assert!(
   87|   160k|            index < file_chars,
   88|      0|            "Index exceeds the number of characters in the source file.\nExpected at most \
   89|      0|             {file_chars}, found {index}.\nSource file: '{}'",
   90|       |            source_file.path
   91|       |        );
   92|       |
   93|   160k|        Self {
   94|   160k|            source_file: Some(source_file),
   95|   160k|            index,
   96|   160k|            line,
   97|   160k|            column,
   98|   160k|        }
   99|   160k|    }
_RNvMNtCsgxSeqfT5AE1_13rustcc_source15source_locationNtB2_14SourceLocation7invalid:
  153|  12.5k|    pub const fn invalid() -> Self {
  154|  12.5k|        Self {
  155|  12.5k|            source_file: None,
  156|  12.5k|            index: 0,
  157|  12.5k|            line: 0,
  158|  12.5k|            column: 0,
  159|  12.5k|        }
  160|  12.5k|    }
_RNCNvMNtCsgxSeqfT5AE1_13rustcc_source15source_locationNtB4_14SourceLocation3new0B6_:
   69|   160k|            .map(|line| line.chars().count());

_RINvMs0_NtCsgxSeqfT5AE1_13rustcc_source14source_managerNtB6_20VirtualSourceManager8add_fileReB1r_ECs8IHyuhOPnlA_12fuzz_compile:
   83|  1.31k|    pub fn add_file<S1: Into<String> + Clone, S2: Into<String>>(&mut self, path: S1, content: S2) {
   84|  1.31k|        self.source_files
   85|  1.31k|            .insert(path.clone().into(), SourceFile::new(path, content));
   86|  1.31k|    }
_RINvXs1_NtCsgxSeqfT5AE1_13rustcc_source14source_managerNtB6_20VirtualSourceManagerNtB6_13SourceManager9load_fileReECs8IHyuhOPnlA_12fuzz_compile:
   90|  1.31k|    fn load_file<S: Into<&'a str>>(&self, path: S) -> Option<&SourceFile> {
   91|  1.31k|        self.source_files.get(path.into())
   92|  1.31k|    }
_RNvMs0_NtCsgxSeqfT5AE1_13rustcc_source14source_managerNtB5_20VirtualSourceManager3new:
   77|  1.31k|    pub fn new() -> Self {
   78|  1.31k|        Self {
   79|  1.31k|            source_files: HashMap::new(),
   80|  1.31k|        }
   81|  1.31k|    }

_RNvMNtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB2_11SourceRange11source_text:
  234|  28.2k|    pub fn source_text(&self) -> Option<&'a str> {
  235|  28.2k|        let source_file = self.begin.source_file?;
  236|       |
  237|  28.2k|        if self.begin == self.end {
  238|  21.0k|            let character = &source_file.content[self.begin.index..].chars().next()?;
  239|  21.0k|            let end_index = self.begin.index + character.len_utf8();
  240|       |
  241|  21.0k|            return source_file.content.get(self.begin.index..end_index);
  242|  7.24k|        }
  243|       |
  244|  7.24k|        source_file.content.get(self.begin.index..=self.end.index)
  245|  28.2k|    }
_RNvMNtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB2_11SourceRange13from_location:
  138|  87.6k|    pub const fn from_location(location: SourceLocation<'a>) -> Self {
  139|  87.6k|        Self {
  140|  87.6k|            begin: location,
  141|  87.6k|            end: location,
  142|  87.6k|        }
  143|  87.6k|    }
_RNvMNtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB2_11SourceRange3new:
   69|  25.2k|    pub fn new(begin: SourceLocation<'a>, end: SourceLocation<'a>) -> Self {
   70|  25.2k|        assert!(
   71|  25.2k|            begin.source_file == end.source_file,
   72|      0|            "Begin and end must be in the same file.\nBegin: {begin}\nEnd:   {end}\nBegin index: \
   73|      0|             {}\nEnd index:   {}",
   74|       |            begin.index,
   75|       |            end.index,
   76|       |        );
   77|  25.2k|        assert!(
   78|  25.2k|            begin.line <= end.line,
   79|      0|            "Begin location must be before end location.\nBegin: {begin}\nEnd:   {end}\nBegin \
   80|      0|             index: {}\nEnd index:   {}",
   81|       |            begin.index,
   82|       |            end.index,
   83|       |        );
   84|  25.2k|        assert!(
   85|  25.2k|            begin.line != end.line || begin.column <= end.column,
   86|      0|            "Begin location must be before end location.\nBegin: {begin}\nEnd:   {end}\nBegin \
   87|      0|             index: {}\nEnd index:   {}",
   88|       |            begin.index,
   89|       |            end.index,
   90|       |        );
   91|  25.2k|        assert!(
   92|  25.2k|            begin.index <= end.index,
   93|      0|            "Begin location must be before end location.\nBegin: {begin}\nEnd:   {end}\nBegin \
   94|      0|             index: {}\nEnd index:   {}",
   95|       |            begin.index,
   96|       |            end.index,
   97|       |        );
   98|  25.2k|        assert!(
   99|  25.2k|            begin.line != end.line || begin.column != end.column || begin.index == end.index,
  100|      0|            "If begin and end are on the same line and are on the same column they must have the \
  101|      0|             same index.\nBegin: {begin}\nEnd:   {end}\nBegin index: {}\nEnd index:   {}",
  102|       |            begin.index,
  103|       |            end.index,
  104|       |        );
  105|       |
  106|  25.2k|        Self { begin, end }
  107|  25.2k|    }
_RNvMNtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB2_11SourceRange7invalid:
  166|  4.97k|    pub const fn invalid() -> Self {
  167|  4.97k|        Self {
  168|  4.97k|            begin: SourceLocation::invalid(),
  169|  4.97k|            end: SourceLocation::invalid(),
  170|  4.97k|        }
  171|  4.97k|    }
_RNvXs0_NtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB5_11SourceRangeINtNtCs6SNw0SRvItZ_4core7convert4FromNtNtB7_15source_location14SourceLocationE4from:
  255|  87.6k|    fn from(location: SourceLocation<'a>) -> Self {
  256|  87.6k|        Self::from_location(location)
  257|  87.6k|    }
_RNvXs_NtCsgxSeqfT5AE1_13rustcc_source12source_rangeNtB4_11SourceRangeNtNtCs6SNw0SRvItZ_4core7default7Default7default:
  249|  4.97k|    fn default() -> Self {
  250|  4.97k|        Self::invalid()
  251|  4.97k|    }

_RNCNvNvCs8IHyuhOPnlA_12fuzz_compile1__19___libfuzzer_sys_run0B5_:
   55|  1.31k|    CODEGEN.with(|slot| {
   56|  1.31k|        let mut codegen = slot.borrow_mut();
   57|       |        // Create a fresh module inside the existing context
   58|  1.31k|        let _ = codegen.reset_module(INPUT_FILE);
   59|       |
   60|  1.31k|        codegen.codegen(&translation_unit);
   61|  1.31k|    });

